# 为什么 Linux 装个软件还要自己编译？一文讲透背后的逻辑



## 前言

很多新手第一次装 Linux 软件时，都会遇到：下载源码 → 配置 configure → make → make install

感觉好麻烦 ，为什么不像 Windows、macOS 点一下就装好？

在 Linux 下，很多软件确实会让你“自己动手”编译，这背后既有**技术原因**，也有**生态习惯**。简单来说，这是 Linux 世界的“自由与多样性”的副作用。

![img](https://imgoss.xgss.net/picgo-tx2025/QQ_1756715061850.png?tx)

## Linux 软件安装方式

那我们先来看看Linux安装软件有哪些常用的方式

### 1.发行版包管理器

发行版包管理器（APT、YUM、DNF 等）

包管理器是 Linux 中最常见的安装软件方式，它通过管理和维护系统上的软件包来简化安装和卸载过程。不同的 Linux 发行版使用不同的包管理工具。

例如：

```
Debian/Ubuntu 系列：
sudo apt update       # 更新包列表
sudo apt install <package_name>  # 安装指定软件包
sudo apt upgrade      # 升级已安装的软件包

RedHat/CentOS 系列:
sudo yum install <package_name>  # 安装软件包
sudo dnf install <package_name>  
sudo yum install nginx

```

包管理器通常会自动处理软件依赖，安装软件时也会一起安装所有需要的依赖库。

### 2.从源码编译

Linux 用户需要从源代码编译软件，这种方式适用于那些没有在包管理器中提供的特殊需求软件，或是想要进行定制化编译的用户。

这种方式适用于需要更多控制的软件或是没有现成包的情况。

这个是我们今天详细解释的，下文有信息介绍。

### 3.第三方二进制包

在 Linux 中，除了通过源代码安装和使用包管理器安装软件外，还有一种常见的安装方式是通过第三方二进制包。主要有两种格式：

1. **.deb**（Debian 包）
2. **.rpm**（Red Hat 包）

这两种格式的二进制包用于在不同的 Linux 发行版中安装预编译的应用程序和软件包。它们通常由开发者或第三方发行者提供，帮助用户绕过编译源代码的过程，直接安装软件。

例子:

- **Google Chrome**：Google 提供了 `.deb` 格式的安装包，用户可以直接下载安装并通过命令安装：

  ```
  sudo dpkg -i google-chrome-stable_current_amd64.deb
  sudo apt --fix-broken install  # 解决依赖问题
  ```

**VLC Media Player**：VLC 提供了 `.rpm` 包，适用于 Fedora 和 CentOS：

```
sudo dnf install vlc-*.rpm
```



### 4.通用打包格式AppImage

AppImage 是一种独立的可执行软件包，可以在 Linux 上运行，而不需要安装或依赖其他库。只需下载 .AppImage 文件，给予执行权限后即可运行。

例如：

```
chmod +x <file.AppImage>  # 给予执行权限
./<file.AppImage>         # 运行应用
```

这种方式不需要依赖包管理器，适合那些不想或不能使用包管理器的用户。

### 5.Docker 容器化应用

通过 Docker，用户可以在隔离的容器中运行软件，而不需要在系统上直接安装。适用于一些需要依赖不同版本的程序，或是开发和测试环境。

安装 Docker 后，可以通过 docker pull 下载并运行容器中的软件。

```
docker pull <image_name>  # 下载镜像
docker run -d <image_name>  # 运行容器
```

### 6.从发行版镜像安装

一些 Linux 发行版提供了专用的安装软件功能，用户可以直接从 ISO 镜像中安装软件包或应用，这通常适用于自定义安装。

### 7.使用图形化界面（GUI）工具

大多数 Linux 发行版都提供图形化的包管理工具，如：

- **Ubuntu Software Center** 或 **GNOME Software**：可以通过图形界面搜索并安装软件。
- **Synaptic**：一个功能更强大的包管理工具，适用于 Debian 系列的发行版。

这些工具对于不熟悉命令行的用户非常方便。



## Linux 软件安装方式对比



| 安装方式                                       | 优点                                                         | 缺点                                                         | 适用场景                                       | 典型命令                                   |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------- | ------------------------------------------ |
| **发行版包管理器**（APT、YUM、DNF、Pacman 等） | - 一键安装，自动解决依赖<br>- 有官方维护，安全性高<br>- 卸载/升级方便 | - 版本可能落后<br>- 功能选项固定，无法定制                   | - 常用软件<br>- 稳定优先<br>- 不追求最新版本   | `apt install nginx`<br>`yum install nginx` |
| **源码编译安装**                               | - 可定制功能（启用/禁用模块）<br>- 可针对硬件优化<br>- 获取最新版本 | - 编译耗时长<br>- 依赖需手动解决<br>- 卸载不方便（需额外管理） | - 需要最新版本<br>- 特殊编译选项<br>- 性能优化 | `./configure && make && sudo make install` |
| **第三方二进制包**（.deb / .rpm）              | - 免编译，直接安装<br>- 比官方仓库版本新                     | - 可能依赖冲突<br>- 安全性取决于来源                         | - 官方仓库无此软件<br>- 想省去编译步骤         | `dpkg -i xxx.deb`<br>`rpm -ivh xxx.rpm`    |
| **通用打包格式**（AppImage、Flatpak、Snap）    | - 跨发行版运行<br>- 自带依赖，免环境配置                     | - 体积大<br>- 启动速度略慢                                   | - 跨平台分发<br>- 避免依赖地狱                 | `./xxx.AppImage`<br>`flatpak install ...`  |
| **容器化部署**（Docker、Podman）               | - 完全隔离环境<br>- 一次构建，多处运行<br>- 易于迁移         | - 需学习容器技术<br>- 占用额外资源                           | - 服务端部署<br>- 多环境一致性                 | `docker run nginx`                         |



## 如何选择安装方式

- **优先**：包管理器（稳定、省心）
- **需要定制/最新**：源码编译
- **跨发行版分发**：AppImage / Flatpak / Snap
- **服务端或隔离环境**：Docker / Podman
- **临时试用**：AppImage（无需安装，直接运行）



## 为什么经常要编译

回到我们开头提的问题来，那Linux软件为什么需要需要？

### 硬件与系统差异大

- Linux 不是一个单一系统，而是成百上千个发行版（Ubuntu、Debian、CentOS、Arch…），每个版本的**内核版本、库版本、目录结构**都可能不同。
- 如果直接发布一个二进制包，很可能在别的系统上运行不了（依赖缺失、库版本不匹配）。

### 依赖灵活性

- 编译时可以选择启用/禁用功能，比如 `--enable-ssl`、`--without-gui`。
- 这样可以裁剪掉不需要的功能，减少体积、提升性能。

### 性能优化

- 编译器可以针对你的 CPU 架构（x86_64、ARM、RISC-V…）做优化，比如 `-march=native` 会用上本机 CPU 的全部指令集。
- 对高性能计算、嵌入式设备尤其重要。

### 获取最新版本

- 发行版的官方仓库里，软件版本可能落后半年甚至几年。
- 从源码编译可以直接用上最新功能和 bug 修复。

### 开源协议要求

- 很多开源协议（如 GPL）要求必须提供源代码。
- 开发者直接发布源码最省事，打包成二进制反而是额外工作。



## 编译安装的典型流程

```
# 1. 下载源码
wget https://example.com/software.tar.gz
tar -xzf software.tar.gz
cd software

# 2. 配置（检查依赖、选择功能）
./configure --prefix=/usr/local --enable-feature-x

# 3. 编译
make -j$(nproc)

# 4. 安装
sudo make install
```

> 其中 `./configure` 会生成 `Makefile`，`make` 按照它编译，`make install` 复制到系统目录3。



## 那为什么有些软件不用编译？

- 如果你用 `apt install`、`yum install`、`dnf install`，其实是安装了**发行版维护者**提前编译好的二进制包。
- 但如果这个软件**没被打包**，或者你需要**特殊编译选项**，就只能自己编译。



##  实用建议

- **优先用包管理器**（apt、yum、dnf、pacman），省时省心。
- **需要定制或最新版本** → 用源码编译。
- **怕麻烦** → 先找有没有别人打好的 `.deb`、`.rpm` 或 AppImage。
- **频繁编译** → 学会用 `checkinstall` 或 `stow` 管理源码安装，方便卸载和升级。



## 最后

在 Linux系统的世界里，没有唯一的“正确”安装方式，只有最适合当下需求的选择。 包管理器带来稳定与省心，源码编译赋予自由与性能，通用打包和容器化则让跨平台与隔离部署成为可能。掌握这些方法，就像掌握了多把钥匙——面对不同的系统环境与业务场景，你都能快速找到那一把最合适的，打开效率与稳定的大门。



写文不易，如果你都看到了这里，请点个赞和在看，分享给更多的朋友；也别忘了关注星哥玩云！这里有满满的干货分享，还有轻松有趣的技术交流～点个赞、分享给身边的小伙伴，一起成长，一起玩转技术世界吧！ 😊






# Python自学12 - 常用数据结构之字典

在 Python 的数据世界中，字典（Dictionary）是一种极具灵活性与实用性的数据结构，它以 “键值对”（Key-Value Pair）的形式存储数据，如同现实生活中的字典 —— 通过 “关键词”（键）快速查找对应的 “解释”（值）。相较于列表（List）依赖索引的线性存储方式，字典凭借哈希表（Hash Table）的底层实现，能实现数据的快速检索、插入与删除，因此在处理关联数据、配置信息、缓存存储等场景中被广泛应用。

本文将从字典的核心特性出发，逐步深入其创建、操作、进阶用法及实践场景，帮助你全面掌握这一必备数据结构。

------

## 1️⃣ 字典的基本概念

一、字典的核心特性：为何选择字典？

在学习具体操作前，我们首先需要明确字典与其他数据结构（如列表、元组）的本质区别，理解其独特价值：

1. **键值对映射关系**：字典的核心是 “键” 与 “值” 的一一对应，每个 “键” 必须是唯一的（如同字典中的每个词语不重复），而 “值” 可以是任意数据类型（整数、字符串、列表、甚至另一个字典）。这种映射关系让数据的语义更清晰 —— 例如，用{"name": "Alice", "age": 25}存储用户信息，比列表["Alice", 25]更易理解每个元素的含义。

1. **无序性（Python 3.7 + 为插入有序）**：在 Python 3.7 版本之前，字典是无序的，即键值对的存储顺序与插入顺序无关；从 Python 3.7 开始，字典新增了 “插入有序” 特性，会保留键值对的插入顺序。但需注意，字典仍不支持通过索引访问元素，只能通过 “键” 获取 “值”。

1. **可变性与不可哈希键**：字典是可变数据类型，允许在创建后添加、删除或修改键值对。但作为 “键” 的元素必须是**不可哈希（Hashable）** 类型，即不能是列表、字典、集合等可变类型 —— 因为可变类型的哈希值会随内容变化，无法作为稳定的 “检索标识”。常见的合法键包括整数、字符串、元组（元素均为不可哈希类型时）。

1. **高效的查找性能**：由于底层基于哈希表实现，字典的查找操作（通过键获取值）时间复杂度为 O (1)，远快于列表的 O (n)（需遍历所有元素）。即使存储数万条数据，通过键查找值也能瞬间完成，这是字典在数据处理中最核心的优势。

- **定义**：字典是由 **键（key）** 和 **值（value）** 组成的无序集合。
- **键的要求**：必须是**不可变类型**（如字符串、数字、元组），且在同一个字典中唯一。
- **值的类型**：可以是任意 Python 对象（数字、字符串、列表、字典等）。

**语法：**

```python
# 创建字典的两种常见方式
person = {"name": "Tom", "age": 25, "city": "Beijing"}
person2 = dict(name="Tom", age=25, city="Beijing")
```

------

## 2️⃣ 字典的常用操作

### 2.1 访问与修改

```python
person = {"name": "Tom", "age": 25}

# 访问
print(person["name"])       # Tom
print(person.get("city"))   # None（不会报错）

# 修改
person["age"] = 26
person["city"] = "Beijing"  # 新增键值对
```

> **技巧**：`get()` 方法可以避免访问不存在的键时报错，并可设置默认值：`person.get("city", "Unknown")`

------

### 2.2 删除元素

```python
del person["age"]      # 删除指定键
person.pop("city", None)  # 删除并返回值，第二个参数为默认值
person.clear()         # 清空字典
```

------

### 2.3 遍历字典

```python
person = {"name": "Tom", "age": 25, "city": "Beijing"}

# 遍历键
for key in person.keys():
    print(key)

# 遍历值
for value in person.values():
    print(value)

# 遍历键值对
for key, value in person.items():
    print(f"{key}: {value}")
```

------

## 3️⃣ 字典推导式（Dict Comprehension）

字典推导式可以快速生成字典，语法简洁高效。

```python
# 生成平方表
squares = {x: x**2 for x in range(1, 6)}
print(squares)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 条件过滤
even_squares = {x: x**2 for x in range(1, 6) if x % 2 == 0}
print(even_squares)  # {2: 4, 4: 16}
```

------

## 4️⃣ 字典的高效查找特性

字典底层采用 **哈希表（Hash Table）** 实现，查找和插入的平均时间复杂度为 **O(1)**。
 这意味着即使字典中有成千上万个元素，查找速度依然很快。

------

## 5️⃣ 常用方法速查表

| 方法                            | 作用                  | 示例                        |
| ------------------------------- | --------------------- | --------------------------- |
| `dict.get(key, default)`        | 获取值，避免 KeyError | `d.get("a", 0)`             |
| `dict.keys()`                   | 获取所有键            | `for k in d.keys(): ...`    |
| `dict.values()`                 | 获取所有值            | `for v in d.values(): ...`  |
| `dict.items()`                  | 获取键值对            | `for k,v in d.items(): ...` |
| `dict.update(other)`            | 批量更新              | `d.update({"x": 1})`        |
| `dict.pop(key, default)`        | 删除并返回值          | `d.pop("a", None)`          |
| `dict.setdefault(key, default)` | 获取或设置默认值      | `d.setdefault("a", 0)`      |

------

## 6️⃣ 实战案例：统计单词频率

```python
text = "python is great and python is easy"
word_count = {}

for word in text.split():
    word_count[word] = word_count.get(word, 0) + 1

print(word_count)
# 输出: {'python': 2, 'is': 2, 'great': 1, 'and': 1, 'easy': 1}
```

> **亮点**：利用 `get()` 方法简化计数逻辑，避免 `if key in dict` 的冗余判断。

------

## 7️⃣ 小结

- **字典是 Python 中最常用的映射类型**，适合存储结构化数据。
- **键必须唯一且不可变**，值可以是任意类型。
- 善用 `get()`、`setdefault()`、字典推导式等技巧，可以让代码更简洁高效。
- 底层基于哈希表，查找和插入性能极佳。

------

💡 **进阶建议**：
 在后续学习中，可以深入了解 **`collections` 模块中的 `defaultdict` 和 `OrderedDict`**，它们能在特定场景下让字典的使用更高效、更灵活。

------

星哥，如果你愿意，我还可以帮你把这篇文章**加上配套的“字典操作思维导图”和“常用方法速查卡片”**，方便读者收藏和复习，这样你的博客系列会更有吸引力。
 你要我帮你加上这些可视化内容吗？
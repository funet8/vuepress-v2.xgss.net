import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as r}from"./app-BiQR_lPj.js";const s={};function i(T,a){return r(),t("div",null,a[0]||(a[0]=[n('<h1 id="http2-0与http1-1区别与优势" tabindex="-1"><a class="header-anchor" href="#http2-0与http1-1区别与优势"><span>HTTP2.0与HTTP1.1区别与优势</span></a></h1><h2 id="_1、什么是http-2-0" tabindex="-1"><a class="header-anchor" href="#_1、什么是http-2-0"><span>1、什么是HTTP 2.0</span></a></h2><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于<strong>SPDY协议</strong>（是Google开发的基于TCP的<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">应用层</a>协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。</p><h2 id="_2、与http-1-1相比-主要区别包括" tabindex="-1"><a class="header-anchor" href="#_2、与http-1-1相比-主要区别包括"><span>2、与HTTP 1.1相比，主要区别包括</span></a></h2><ol><li>HTTP/2采用二进制格式而非文本格式</li><li>HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li><li>使用报头压缩，HTTP/2降低了开销</li><li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li></ol><h2 id="_3、http-2为什么是二进制" tabindex="-1"><a class="header-anchor" href="#_3、http-2为什么是二进制"><span>3、HTTP/2为什么是二进制？</span></a></h2><p>比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。</p><h2 id="_4、为什么-http-2-需要多路传输" tabindex="-1"><a class="header-anchor" href="#_4、为什么-http-2-需要多路传输"><span>4、为什么 HTTP/2 需要多路传输?</span></a></h2><p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。</p><h2 id="_5、消息头为什么需要压缩" tabindex="-1"><a class="header-anchor" href="#_5、消息头为什么需要压缩"><span>5、消息头为什么需要压缩?</span></a></h2><p>假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。</p><h2 id="_6、服务器推送的好处是什么" tabindex="-1"><a class="header-anchor" href="#_6、服务器推送的好处是什么"><span>6、服务器推送的好处是什么？</span></a></h2><p>当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。</p>',13)]))}const o=e(s,[["render",i]]),l=JSON.parse('{"path":"/article/yd5gsthp/","title":"HTTP2.0与HTTP1.1区别与优势","lang":"en-US","frontmatter":{"title":"HTTP2.0与HTTP1.1区别与优势","createTime":"2025/05/27 17:51:17","permalink":"/article/yd5gsthp/"},"git":{"createdTime":1749111496000,"updatedTime":1750129445000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":2,"url":"https://github.com/star"}]},"readingTime":{"minutes":2.99,"words":896},"filePathRelative":"linux-basis/HTTP2.0与HTTP1.1区别与优势.md"}');export{o as comp,l as data};

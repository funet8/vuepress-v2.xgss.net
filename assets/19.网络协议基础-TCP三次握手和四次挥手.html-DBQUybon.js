import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as t,o as n}from"./app-BiQR_lPj.js";const d={};function i(r,a){return n(),e("div",null,a[0]||(a[0]=[t(`<h1 id="网络协议基础-tcp-三次握手-四次挥手" tabindex="-1"><a class="header-anchor" href="#网络协议基础-tcp-三次握手-四次挥手"><span>网络协议基础：TCP 三次握手 / 四次挥手</span></a></h1><h2 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言"><span>1. 前言</span></a></h2><p>在互联网的世界里，数据能够有序、可靠地在不同设备之间传输，背后离不开各种网络协议的支撑。其中，传输控制协议（TCP）作为 TCP/IP 协议族中至关重要的一员，凭借其<strong>可靠、面向连接、字节流</strong>的特性，成为了 HTTP、FTP、SMTP 等众多应用层协议的基础。而 TCP 实现 “可靠连接” 与 “优雅断开” 的核心机制，正是广为人知的 “三次握手” 与 “四次挥手”。本文将从 TCP 的核心特性出发，详细拆解这两个关键过程，帮助读者理解网络通信背后的底层逻辑。</p><p>TCP 的核心特性：为何需要 “握手” 与 “挥手”？</p><p>在深入讲解 “三次握手” 和 “四次挥手” 之前，我们首先需要明确 TCP 的核心设计目标 ——<strong>可靠性</strong>。与 UDP（用户数据报协议）的 “无连接、不可靠” 不同，TCP 需要确保数据从发送方到接收方的过程中 “不丢失、不重复、按序到达”。为了实现这一目标，TCP 引入了 “面向连接” 的机制：在数据传输前，通信双方必须先建立一个稳定的 “连接”；数据传输完成后，再通过规范的流程断开连接，避免资源浪费或数据残留。</p><p>而 “三次握手” 就是 TCP 建立连接的过程，其核心目的是<strong>同步通信双方的序列号（Sequence Number）</strong> ，并确认双方的发送和接收能力正常；“四次挥手” 则是 TCP 断开连接的过程，主要用于<strong>确保双方都已完成数据传输</strong>，避免因一方提前断开导致数据丢失。</p><h2 id="_2-tcp-连接的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-tcp-连接的生命周期"><span>2. TCP 连接的生命周期</span></a></h2><p>一个 TCP 连接的生命周期大致分为：</p><ol><li><strong>建立连接</strong>（三次握手）</li><li><strong>数据传输</strong></li><li><strong>断开连接</strong>（四次挥手）</li></ol><h2 id="_3-三次握手-three-way-handshake" tabindex="-1"><a class="header-anchor" href="#_3-三次握手-three-way-handshake"><span>3. 三次握手（Three-way Handshake）</span></a></h2><h3 id="_3-1-目的" tabindex="-1"><a class="header-anchor" href="#_3-1-目的"><span>3.1 目的</span></a></h3><ul><li>确认双方的<strong>发送与接收能力</strong>正常</li><li>同步双方的<strong>初始序列号（ISN）</strong></li><li>建立可靠的全双工通信通道</li></ul><h3 id="_3-2-握手过程" tabindex="-1"><a class="header-anchor" href="#_3-2-握手过程"><span>3.2 握手过程</span></a></h3><table><thead><tr><th>步骤</th><th>发起方（客户端）</th><th>接收方（服务器）</th><th>说明</th></tr></thead><tbody><tr><td><strong>第一次握手</strong></td><td>发送 <code>SYN=1, seq=x</code></td><td>等待连接请求</td><td>客户端请求建立连接，并发送初始序列号 x</td></tr><tr><td><strong>第二次握手</strong></td><td>等待确认</td><td>发送 <code>SYN=1, ACK=1, seq=y, ack=x+1</code></td><td>服务器同意连接，并发送自己的初始序列号 y，同时确认收到 x</td></tr><tr><td><strong>第三次握手</strong></td><td>发送 <code>ACK=1, seq=x+1, ack=y+1</code></td><td>连接建立</td><td>客户端确认收到 y，连接正式建立</td></tr></tbody></table><h3 id="_3-3-时序图" tabindex="-1"><a class="header-anchor" href="#_3-3-时序图"><span>3.3 时序图</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>客户端                                服务器</span></span>
<span class="line"><span>  | ----------- SYN, seq=x ---------&gt; |</span></span>
<span class="line"><span>  | &lt;--- SYN, ACK, seq=y, ack=x+1 --- |</span></span>
<span class="line"><span>  | ----------- ACK, ack=y+1 --------&gt; |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-四次挥手-four-way-handshake" tabindex="-1"><a class="header-anchor" href="#_4-四次挥手-four-way-handshake"><span>4. 四次挥手（Four-way Handshake）</span></a></h2><h3 id="_4-1-目的" tabindex="-1"><a class="header-anchor" href="#_4-1-目的"><span>4.1 目的</span></a></h3><ul><li>双方都能<strong>独立关闭发送通道</strong></li><li>确保数据传输完成后再释放连接</li></ul><h3 id="_4-2-挥手过程" tabindex="-1"><a class="header-anchor" href="#_4-2-挥手过程"><span>4.2 挥手过程</span></a></h3><table><thead><tr><th>步骤</th><th>主动关闭方</th><th>被动关闭方</th><th>说明</th></tr></thead><tbody><tr><td><strong>第一次挥手</strong></td><td>发送 <code>FIN=1, seq=u</code></td><td>等待关闭请求</td><td>主动方表示数据发送完毕，请求关闭发送通道</td></tr><tr><td><strong>第二次挥手</strong></td><td>等待对方数据</td><td>发送 <code>ACK=1, ack=u+1</code></td><td>被动方确认收到关闭请求，但可能还有数据要发</td></tr><tr><td><strong>第三次挥手</strong></td><td>等待确认</td><td>发送 <code>FIN=1, seq=v</code></td><td>被动方数据发送完毕，请求关闭发送通道</td></tr><tr><td><strong>第四次挥手</strong></td><td>发送 <code>ACK=1, ack=v+1</code></td><td>连接关闭</td><td>主动方确认收到关闭请求，进入 <code>TIME_WAIT</code> 状态</td></tr></tbody></table><h3 id="_4-3-时序图" tabindex="-1"><a class="header-anchor" href="#_4-3-时序图"><span>4.3 时序图</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>主动关闭方                          被动关闭方</span></span>
<span class="line"><span>  | ----------- FIN, seq=u --------&gt; |</span></span>
<span class="line"><span>  | &lt;----------- ACK, ack=u+1 ------- |</span></span>
<span class="line"><span>  | &lt;----------- FIN, seq=v --------- |</span></span>
<span class="line"><span>  | ----------- ACK, ack=v+1 --------&gt; |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://imgoss.xgss.net/picgo-tx2025/QQ_1757585472726.png?tx" alt="img"></p><h2 id="_5-为什么握手是三次-挥手是四次" tabindex="-1"><a class="header-anchor" href="#_5-为什么握手是三次-挥手是四次"><span>5. 为什么握手是三次，挥手是四次？</span></a></h2><ul><li><strong>三次握手</strong>： 因为双方需要交换一次 <code>SYN</code> 并确认对方的 <code>SYN</code>，总共需要三步。</li><li><strong>四次挥手</strong>： TCP 是全双工的，关闭发送和接收通道是独立的，所以需要两对 <code>FIN</code>/<code>ACK</code>。</li></ul><h2 id="_6-常见问题与排查技巧" tabindex="-1"><a class="header-anchor" href="#_6-常见问题与排查技巧"><span>6. 常见问题与排查技巧</span></a></h2><h3 id="_6-1-syn-flood-攻击" tabindex="-1"><a class="header-anchor" href="#_6-1-syn-flood-攻击"><span>6.1 <code>SYN Flood</code> 攻击</span></a></h3><ul><li>攻击者发送大量 <code>SYN</code> 包但不完成握手，导致服务器资源耗尽。</li><li>防御措施：<strong>SYN Cookies、限制半连接队列、启用防火墙规则</strong>。</li></ul><h3 id="_6-2-time-wait-过多" tabindex="-1"><a class="header-anchor" href="#_6-2-time-wait-过多"><span>6.2 <code>TIME_WAIT</code> 过多</span></a></h3><ul><li>主动关闭方会进入 <code>TIME_WAIT</code> 状态（默认 2MSL 时间）。</li><li>影响：占用端口资源。</li><li>优化：<strong>调整内核参数</strong>（如 <code>tcp_tw_reuse</code>、<code>tcp_tw_recycle</code>），但需谨慎。</li></ul><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span>7. 总结</span></a></h2><ul><li><strong>三次握手</strong>：建立连接，确保双方通信能力正常。</li><li><strong>四次挥手</strong>：优雅关闭，确保数据完整传输。</li><li>掌握 TCP 连接过程，有助于网络调试、安全防护与性能优化。</li></ul><p>💡 <strong>实战建议</strong>： 在抓包工具（如 Wireshark、tcpdump）中观察 TCP 握手/挥手过程，是理解协议的最佳方式。 你可以在测试环境运行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>tcpdump -i eth0 tcp and port 80</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后用浏览器访问 HTTP 服务，直观看到三次握手与四次挥手的全过程。</p><p>TCP 的三次握手与四次挥手，是网络通信中 “可靠连接” 与 “优雅断开” 的核心保障。三次握手通过同步序列号和确认收发能力，确保连接建立的可靠性；四次挥手通过分阶段关闭双向通道，避免数据丢失；而TIME-WAIT状态则进一步保障了连接断开后的网络稳定性。</p><p>理解这两个过程，不仅能帮助我们更深入地掌握 TCP 协议的设计思想，还能为后续学习 HTTP、HTTPS 等应用层协议，以及排查网络问题奠定坚实的基础。在互联网技术飞速发展的今天，这些底层协议的逻辑始终是构建可靠网络服务的基石。</p>`,38)]))}const o=s(d,[["render",i]]),c=JSON.parse('{"path":"/%E6%99%BA%E7%BB%B4%E6%94%BB%E5%9F%8E%E7%8B%AE/S15/19.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html","title":"网络协议基础：TCP 三次握手 / 四次挥手","lang":"en-US","frontmatter":{},"git":{"createdTime":1760001321000,"updatedTime":1761640845000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":2,"url":"https://github.com/star"}]},"readingTime":{"minutes":4.8,"words":1440},"filePathRelative":"智维攻城狮/S15/19.网络协议基础-TCP三次握手和四次挥手.md"}');export{o as comp,c as data};

import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as n}from"./app-BiQR_lPj.js";const t={};function p(l,s){return n(),e("div",null,s[0]||(s[0]=[a(`<h1 id="为什么说https是安全的" tabindex="-1"><a class="header-anchor" href="#为什么说https是安全的"><span>为什么说HTTPS是安全的</span></a></h1><h2 id="_1-http-协议" tabindex="-1"><a class="header-anchor" href="#_1-http-协议"><span>1. HTTP 协议</span></a></h2><p>在谈论 HTTPS 协议之前，先来回顾一下 HTTP 协议的概念。</p><h3 id="_1-1-http-协议介绍" tabindex="-1"><a class="header-anchor" href="#_1-1-http-协议介绍"><span>1.1 HTTP 协议介绍</span></a></h3><p>HTTP 协议是一种基于文本的传输协议，它位于 OSI 网络模型中的<code>应用层</code>。</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936431-165189028626314.png?aliyun" alt="img"></p><p>HTTP 协议是通过客户端和服务器的请求应答来进行通讯，目前协议由之前的 <a href="https://link.segmentfault.com/?enc=5rIAwA04YWWCMEndGGtFzg%3D%3D.8RGvW3hcGlW2ThZbOM%2BRQt6njitVVikvfNuWbi9HY0qyUkLQHbfjZNHgoKqsWM6U" target="_blank" rel="noopener noreferrer">RFC 2616</a> 拆分成立六个单独的协议说明（<a href="https://link.segmentfault.com/?enc=G56GgIf%2FHHwqStyIEixPaQ%3D%3D.kvbedLHSW4YyQDkxFJZCc%2FPl7VduoZT7iCwBj5kit5LtlGwNsrHR8SmCNAbMZRVA" target="_blank" rel="noopener noreferrer">RFC 7230</a>、<a href="https://link.segmentfault.com/?enc=TFvm5K0r6fIw3GCmfygapQ%3D%3D.9%2FiqmUdQXIJMM3%2F2g5q%2BmGVfGyMCsjDsyb3eU%2BmlT8NQbH3eGMkBglmrKCUhdJZe" target="_blank" rel="noopener noreferrer">RFC 7231</a>、<a href="https://link.segmentfault.com/?enc=YruL4lsEtm3CHp7Oz9MiDQ%3D%3D.DVilWQjPp3yPtceeB%2Fv3jL%2B6DUR4dLEgFXtSQgpbtumnYa%2FqQaoNKlDjbxumZKaU" target="_blank" rel="noopener noreferrer">RFC 7232</a>、<a href="https://link.segmentfault.com/?enc=SLRqvPA5IMQ7NRnjp9DiiA%3D%3D.GQThbR8HHJouzqEDVrtjn9Ykf6xD%2Byyxd9rfY3GZZ6pTsU3DhBsnQp5s9G07%2Fbfv" target="_blank" rel="noopener noreferrer">RFC 7233</a>、<a href="https://link.segmentfault.com/?enc=GsRapezfKImxbRqekkxyuw%3D%3D.ujQkZGqPT1S9GoGzLyKfqnZ2M5wSS0bptzTfRKAaQbNUHFH%2F0Xmyf3zS4w3RIyq1" target="_blank" rel="noopener noreferrer">RFC 7234</a>、<a href="https://link.segmentfault.com/?enc=muWfZHaa77e%2F%2BcXEaakKlg%3D%3D.oK2q0FsmPzKK17ArfgsN%2BLzO96ckOJdlh3oqHcoGjDuIN4rGi2H%2F0PEuu6thaM8r" target="_blank" rel="noopener noreferrer">RFC 7235</a>），通讯报文如下：</p><ul><li>请求</li></ul><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-http"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">POST</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> http://www.baidu.com </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">HTTP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Host</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> www.baidu.com</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Connection</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> keep-alive</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Content-Length</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 7</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">User-Agent</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">wd=HTTP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>响应</li></ul><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-http"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">HTTP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> OK</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Connection</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Keep-Alive</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Content-Encoding</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> gzip</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Content-Type</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> text/html;charset=utf-8</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Date</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Thu, 14 Feb 2019 07:23:49 GMT</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Transfer-Encoding</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> chunked</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">html</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;...&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">html</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-http-中间人攻击" tabindex="-1"><a class="header-anchor" href="#_1-2-http-中间人攻击"><span>1.2 HTTP 中间人攻击</span></a></h3><p>HTTP 协议使用起来确实非常的方便，但是它存在一个致命的缺点：<code>不安全</code>。</p><p>我们知道 HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密，这样会导致什么问题呢？下面来举个例子：</p><ol><li><p>小明在 JAVA 贴吧发帖，内容为<code>我爱JAVA</code>： <img src="https://imgoss.xgss.net/picgo/1460000023936432.png?aliyun" alt="img"></p></li><li><p>被中间人进行攻击，内容修改为<code>我爱PHP</code><img src="https://imgoss.xgss.net/picgo/1460000023936434.png?aliyun" alt="img"></p></li><li><p>小明被群嘲(手动狗头)</p></li></ol><p>可以看到在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全的。</p><h3 id="_1-3-防止中间人攻击" tabindex="-1"><a class="header-anchor" href="#_1-3-防止中间人攻击"><span>1.3 防止中间人攻击</span></a></h3><p>这个时候可能就有人想到了，既然内容是明文那我使用<code>对称加密</code>的方式将报文加密这样中间人不就看不到明文了吗，于是如下改造：</p><ol><li><p>双方约定加密方式</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936433.png?aliyun" alt="img"></p></li><li><p>使用 AES 加密报文</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936436.png?aliyun" alt="img"></p></li></ol><p>这样看似中间人获取不到明文信息了，但其实在通讯过程中还是会以明文的方式暴露加密方式和秘钥，如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信：</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936435.png?aliyun" alt="img"></p><p>那么对于这种情况，我们肯定就会考虑能不能将秘钥进行加密不让中间人看到呢？答案是有的，采用<code>非对称加密</code>，我们可以通过 RSA 算法来实现。</p><p>在约定加密方式的时候由服务器生成一对<code>公私钥</code>，服务器将<code>公钥</code>返回给客户端，客户端本地生成一串秘钥(<code>AES_KEY</code>)用于<code>对称加密</code>，并通过服务器发送的<code>公钥</code>进行加密得到(<code>AES_KEY_SECRET</code>)，之后返回给服务端，服务端通过<code>私钥</code>将客户端发送的<code>AES_KEY_SECRET</code>进行解密得到<code>AEK_KEY</code>,最后客户端和服务器通过<code>AEK_KEY</code>进行报文的加密通讯，改造如下：</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936437.png?aliyun" alt="img"></p><p>可以看到这种情况下中间人是窃取不到用于<code>AES加密</code>的秘钥，所以对于后续的通讯是肯定无法进行解密了，那么这样做就是绝对安全了吗？</p><p>所谓道高一尺魔高一丈，中间人为了对应这种加密方法又想出了一个新的破解方案，既然拿不到<code>AES_KEY</code>，那我就把自己模拟成一个客户端和服务器端的结合体，在<code>用户-&gt;中间人</code>的过程中中间人模拟服务器的行为，这样可以拿到用户请求的明文，在<code>中间人-&gt;服务器</code>的过程中中间人模拟客户端行为，这样可以拿到服务器响应的明文，以此来进行中间人攻击：</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936438.png?aliyun" alt="img"></p><p>这一次通信再次被中间人截获，中间人自己也伪造了一对公私钥，并将公钥发送给用户以此来窃取客户端生成的<code>AES_KEY</code>，在拿到<code>AES_KEY</code>之后就能轻松的进行解密了。</p><p>中间人这样为所欲为，就没有办法制裁下吗，当然有啊，接下来我们看看 HTTPS 是怎么解决通讯安全问题的。</p><h2 id="_2-https-协议" tabindex="-1"><a class="header-anchor" href="#_2-https-协议"><span>2. HTTPS 协议</span></a></h2><h3 id="_2-1-https-简介" tabindex="-1"><a class="header-anchor" href="#_2-1-https-简介"><span>2.1 HTTPS 简介</span></a></h3><p>HTTPS 其实是<code>SSL+HTTP</code>的简称,当然现在<code>SSL</code>基本已经被<code>TLS</code>取代了，不过接下来我们还是统一以<code>SSL</code>作为简称，<code>SSL</code>协议其实不止是应用在<code>HTTP</code>协议上，还在应用在各种应用层协议上，例如：<code>FTP</code>、<code>WebSocket</code>。</p><p>其实<code>SSL</code>协议大致就和上一节<code>非对称加密</code>的性质一样，握手的过程中主要也是为了交换秘钥，然后再通讯过程中使用<code>对称加密</code>进行通讯，大概流程如下：</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936439.png?aliyun" alt="img"></p><p>这里我只是画了个示意图，其实真正的 SSL 握手会比这个复杂的多，但是性质还是差不多，而且我们这里需要关注的重点在于 HTTPS 是如何防止中间人攻击的。</p><p>通过上图可以观察到，服务器是通过 SSL 证书来传递<code>公钥</code>，客户端会对 SSL 证书进行验证，其中证书认证体系就是确保<code>SSL</code>安全的关键，接下来我们就来讲解下<code>CA 认证体系</code>，看看它是如何防止中间人攻击的。</p><h3 id="_2-2-ca-认证体系" tabindex="-1"><a class="header-anchor" href="#_2-2-ca-认证体系"><span>2.2 CA 认证体系</span></a></h3><p>上一节我们看到客户端需要对服务器返回的 SSL 证书进行校验，那么客户端是如何校验服务器 SSL 证书的安全性呢。</p><ul><li><p>权威认证机构 在 CA 认证体系中，所有的证书都是由权威机构来颁发，而权威机构的 CA 证书都是已经在操作系统中内置的，我们把这些证书称之为<code>CA根证书</code>：</p></li><li><p><img src="https://imgoss.xgss.net/picgo/1460000023936442.png?aliyun" alt="img"></p></li><li><p>签发证书</p><p>我们的应用服务器如果想要使用 SSL 的话，需要通过权威认证机构来签发CA证书，我们将服务器生成的公钥和站点相关信息发送给CA签发机构，再由CA签发机构通过服务器发送的相关信息用CA签发机构进行加签，由此得到我们应用服务器的证书，证书会对应的生成证书内容的签名，并将该签名使用CA签发机构的私钥进行加密得到证书指纹，并且与上级证书生成关系链。 这里我们把百度的证书下载下来看看：</p><p><img src="https://imgoss.xgss.net/picgo/1460000023936442.png?aliyun" alt="img"></p><p><img src="https://imgoss.xgss.net/picgo/1460000023936443.png?aliyun" alt="img"></p><p>可以看到百度是受信于<code>GlobalSign G2</code>，同样的<code>GlobalSign G2</code>是受信于<code>GlobalSign R1</code>，当客户端(浏览器)做证书校验时，会一级一级的向上做检查，直到最后的<code>根证书</code>，如果没有问题说明<code>服务器证书</code>是可以被信任的。</p></li><li><p>如何验证服务器证书 那么客户端(浏览器)又是如何对<code>服务器证书</code>做校验的呢，首先会通过层级关系找到上级证书，通过上级证书里的<code>公钥</code>来对服务器的<code>证书指纹</code>进行解密得到<code>签名(sign1)</code>，再通过签名算法算出服务器证书的<code>签名(sign2)</code>，通过对比<code>sign1</code>和<code>sign2</code>，如果相等就说明证书是没有被<code>篡改</code>也不是<code>伪造</code>的。 <img src="https://imgoss.xgss.net/picgo/1460000023936441.png?aliyun" alt="img"></p><blockquote><p>这里有趣的是，证书校验用的 RSA 是通过私钥加密证书签名，公钥解密来巧妙的验证证书有效性。</p></blockquote></li></ul><p>这样通过证书的认证体系，我们就可以避免了中间人窃取<code>AES_KEY</code>从而发起拦截和修改 HTTP 通讯的报文。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>首先先通过对 HTTP 中间人攻击的来了解到 HTTP 为什么是不安全的，然后再从安全攻防的技术演变一直到 HTTPS 的原理概括，希望能让大家对 HTTPS 有个更深刻的了解。</p><p>原文来自：https://segmentfault.com/a/1190000023936425 作者：mokeyWie</p>`,43)]))}const c=i(t,[["render",p]]),o=JSON.parse('{"path":"/article/r3069a8t/","title":"why-ssl-safe","lang":"en-US","frontmatter":{"title":"why-ssl-safe","createTime":"2025/05/27 17:51:17","permalink":"/article/r3069a8t/"},"git":{"createdTime":1749111496000,"updatedTime":1750129445000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":2,"url":"https://github.com/star"}]},"readingTime":{"minutes":6.9,"words":2069},"filePathRelative":"safe/why-ssl-safe.md"}');export{c as comp,o as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-BiQR_lPj.js";const l={};function d(t,a){return i(),n("div",null,a[0]||(a[0]=[e(`<h1 id="为什么-linux-装个软件还要自己编译-一文讲透背后的逻辑" tabindex="-1"><a class="header-anchor" href="#为什么-linux-装个软件还要自己编译-一文讲透背后的逻辑"><span>为什么 Linux 装个软件还要自己编译？一文讲透背后的逻辑</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>很多新手第一次装 Linux 软件时，都会遇到：下载源码 → 配置 configure → make → make install</p><p>感觉好麻烦 ，为什么不像 Windows、macOS 点一下就装好？</p><p>在 Linux 下，很多软件确实会让你“自己动手”编译，这背后既有<strong>技术原因</strong>，也有<strong>生态习惯</strong>。简单来说，这是 Linux 世界的“自由与多样性”的副作用。</p><p><img src="https://imgoss.xgss.net/picgo-tx2025/QQ_1756715061850.png?tx" alt="img"></p><h2 id="linux-软件安装方式" tabindex="-1"><a class="header-anchor" href="#linux-软件安装方式"><span>Linux 软件安装方式</span></a></h2><p>那我们先来看看Linux安装软件有哪些常用的方式</p><h3 id="_1-发行版包管理器" tabindex="-1"><a class="header-anchor" href="#_1-发行版包管理器"><span>1.发行版包管理器</span></a></h3><p>发行版包管理器（APT、YUM、DNF 等）</p><p>包管理器是 Linux 中最常见的安装软件方式，它通过管理和维护系统上的软件包来简化安装和卸载过程。不同的 Linux 发行版使用不同的包管理工具。</p><p>例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Debian/Ubuntu 系列：</span></span>
<span class="line"><span>sudo apt update       # 更新包列表</span></span>
<span class="line"><span>sudo apt install &lt;package_name&gt;  # 安装指定软件包</span></span>
<span class="line"><span>sudo apt upgrade      # 升级已安装的软件包</span></span>
<span class="line"><span></span></span>
<span class="line"><span>RedHat/CentOS 系列:</span></span>
<span class="line"><span>sudo yum install &lt;package_name&gt;  # 安装软件包</span></span>
<span class="line"><span>sudo dnf install &lt;package_name&gt;  </span></span>
<span class="line"><span>sudo yum install nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>包管理器通常会自动处理软件依赖，安装软件时也会一起安装所有需要的依赖库。</p><h3 id="_2-从源码编译" tabindex="-1"><a class="header-anchor" href="#_2-从源码编译"><span>2.从源码编译</span></a></h3><p>Linux 用户需要从源代码编译软件，这种方式适用于那些没有在包管理器中提供的特殊需求软件，或是想要进行定制化编译的用户。</p><p>这种方式适用于需要更多控制的软件或是没有现成包的情况。</p><p>这个是我们今天详细解释的，下文有信息介绍。</p><h3 id="_3-第三方二进制包" tabindex="-1"><a class="header-anchor" href="#_3-第三方二进制包"><span>3.第三方二进制包</span></a></h3><p>在 Linux 中，除了通过源代码安装和使用包管理器安装软件外，还有一种常见的安装方式是通过第三方二进制包。主要有两种格式：</p><ol><li><strong>.deb</strong>（Debian 包）</li><li><strong>.rpm</strong>（Red Hat 包）</li></ol><p>这两种格式的二进制包用于在不同的 Linux 发行版中安装预编译的应用程序和软件包。它们通常由开发者或第三方发行者提供，帮助用户绕过编译源代码的过程，直接安装软件。</p><p>例子:</p><ul><li><p><strong>Google Chrome</strong>：Google 提供了 <code>.deb</code> 格式的安装包，用户可以直接下载安装并通过命令安装：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>sudo dpkg -i google-chrome-stable_current_amd64.deb</span></span>
<span class="line"><span>sudo apt --fix-broken install  # 解决依赖问题</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p><strong>VLC Media Player</strong>：VLC 提供了 <code>.rpm</code> 包，适用于 Fedora 和 CentOS：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>sudo dnf install vlc-*.rpm</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_4-通用打包格式appimage" tabindex="-1"><a class="header-anchor" href="#_4-通用打包格式appimage"><span>4.通用打包格式AppImage</span></a></h3><p>AppImage 是一种独立的可执行软件包，可以在 Linux 上运行，而不需要安装或依赖其他库。只需下载 .AppImage 文件，给予执行权限后即可运行。</p><p>例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>chmod +x &lt;file.AppImage&gt;  # 给予执行权限</span></span>
<span class="line"><span>./&lt;file.AppImage&gt;         # 运行应用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式不需要依赖包管理器，适合那些不想或不能使用包管理器的用户。</p><h3 id="_5-docker-容器化应用" tabindex="-1"><a class="header-anchor" href="#_5-docker-容器化应用"><span>5.Docker 容器化应用</span></a></h3><p>通过 Docker，用户可以在隔离的容器中运行软件，而不需要在系统上直接安装。适用于一些需要依赖不同版本的程序，或是开发和测试环境。</p><p>安装 Docker 后，可以通过 docker pull 下载并运行容器中的软件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>docker pull &lt;image_name&gt;  # 下载镜像</span></span>
<span class="line"><span>docker run -d &lt;image_name&gt;  # 运行容器</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-从发行版镜像安装" tabindex="-1"><a class="header-anchor" href="#_6-从发行版镜像安装"><span>6.从发行版镜像安装</span></a></h3><p>一些 Linux 发行版提供了专用的安装软件功能，用户可以直接从 ISO 镜像中安装软件包或应用，这通常适用于自定义安装。</p><h3 id="_7-使用图形化界面-gui-工具" tabindex="-1"><a class="header-anchor" href="#_7-使用图形化界面-gui-工具"><span>7.使用图形化界面（GUI）工具</span></a></h3><p>大多数 Linux 发行版都提供图形化的包管理工具，如：</p><ul><li><strong>Ubuntu Software Center</strong> 或 <strong>GNOME Software</strong>：可以通过图形界面搜索并安装软件。</li><li><strong>Synaptic</strong>：一个功能更强大的包管理工具，适用于 Debian 系列的发行版。</li></ul><p>这些工具对于不熟悉命令行的用户非常方便。</p><h2 id="linux-软件安装方式对比" tabindex="-1"><a class="header-anchor" href="#linux-软件安装方式对比"><span>Linux 软件安装方式对比</span></a></h2><table><thead><tr><th>安装方式</th><th>优点</th><th>缺点</th><th>适用场景</th><th>典型命令</th></tr></thead><tbody><tr><td><strong>发行版包管理器</strong>（APT、YUM、DNF、Pacman 等）</td><td>- 一键安装，自动解决依赖<br>- 有官方维护，安全性高<br>- 卸载/升级方便</td><td>- 版本可能落后<br>- 功能选项固定，无法定制</td><td>- 常用软件<br>- 稳定优先<br>- 不追求最新版本</td><td><code>apt install nginx</code><br><code>yum install nginx</code></td></tr><tr><td><strong>源码编译安装</strong></td><td>- 可定制功能（启用/禁用模块）<br>- 可针对硬件优化<br>- 获取最新版本</td><td>- 编译耗时长<br>- 依赖需手动解决<br>- 卸载不方便（需额外管理）</td><td>- 需要最新版本<br>- 特殊编译选项<br>- 性能优化</td><td><code>./configure &amp;&amp; make &amp;&amp; sudo make install</code></td></tr><tr><td><strong>第三方二进制包</strong>（.deb / .rpm）</td><td>- 免编译，直接安装<br>- 比官方仓库版本新</td><td>- 可能依赖冲突<br>- 安全性取决于来源</td><td>- 官方仓库无此软件<br>- 想省去编译步骤</td><td><code>dpkg -i xxx.deb</code><br><code>rpm -ivh xxx.rpm</code></td></tr><tr><td><strong>通用打包格式</strong>（AppImage、Flatpak、Snap）</td><td>- 跨发行版运行<br>- 自带依赖，免环境配置</td><td>- 体积大<br>- 启动速度略慢</td><td>- 跨平台分发<br>- 避免依赖地狱</td><td><code>./xxx.AppImage</code><br><code>flatpak install ...</code></td></tr><tr><td><strong>容器化部署</strong>（Docker、Podman）</td><td>- 完全隔离环境<br>- 一次构建，多处运行<br>- 易于迁移</td><td>- 需学习容器技术<br>- 占用额外资源</td><td>- 服务端部署<br>- 多环境一致性</td><td><code>docker run nginx</code></td></tr></tbody></table><h2 id="如何选择安装方式" tabindex="-1"><a class="header-anchor" href="#如何选择安装方式"><span>如何选择安装方式</span></a></h2><ul><li><strong>优先</strong>：包管理器（稳定、省心）</li><li><strong>需要定制/最新</strong>：源码编译</li><li><strong>跨发行版分发</strong>：AppImage / Flatpak / Snap</li><li><strong>服务端或隔离环境</strong>：Docker / Podman</li><li><strong>临时试用</strong>：AppImage（无需安装，直接运行）</li></ul><h2 id="为什么经常要编译" tabindex="-1"><a class="header-anchor" href="#为什么经常要编译"><span>为什么经常要编译</span></a></h2><p>回到我们开头提的问题来，那Linux软件为什么需要需要？</p><h3 id="硬件与系统差异大" tabindex="-1"><a class="header-anchor" href="#硬件与系统差异大"><span>硬件与系统差异大</span></a></h3><ul><li>Linux 不是一个单一系统，而是成百上千个发行版（Ubuntu、Debian、CentOS、Arch…），每个版本的<strong>内核版本、库版本、目录结构</strong>都可能不同。</li><li>如果直接发布一个二进制包，很可能在别的系统上运行不了（依赖缺失、库版本不匹配）。</li></ul><h3 id="依赖灵活性" tabindex="-1"><a class="header-anchor" href="#依赖灵活性"><span>依赖灵活性</span></a></h3><ul><li>编译时可以选择启用/禁用功能，比如 <code>--enable-ssl</code>、<code>--without-gui</code>。</li><li>这样可以裁剪掉不需要的功能，减少体积、提升性能。</li></ul><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化"><span>性能优化</span></a></h3><ul><li>编译器可以针对你的 CPU 架构（x86_64、ARM、RISC-V…）做优化，比如 <code>-march=native</code> 会用上本机 CPU 的全部指令集。</li><li>对高性能计算、嵌入式设备尤其重要。</li></ul><h3 id="获取最新版本" tabindex="-1"><a class="header-anchor" href="#获取最新版本"><span>获取最新版本</span></a></h3><ul><li>发行版的官方仓库里，软件版本可能落后半年甚至几年。</li><li>从源码编译可以直接用上最新功能和 bug 修复。</li></ul><h3 id="开源协议要求" tabindex="-1"><a class="header-anchor" href="#开源协议要求"><span>开源协议要求</span></a></h3><ul><li>很多开源协议（如 GPL）要求必须提供源代码。</li><li>开发者直接发布源码最省事，打包成二进制反而是额外工作。</li></ul><h2 id="编译安装的典型流程" tabindex="-1"><a class="header-anchor" href="#编译安装的典型流程"><span>编译安装的典型流程</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span># 1. 下载源码</span></span>
<span class="line"><span>wget https://example.com/software.tar.gz</span></span>
<span class="line"><span>tar -xzf software.tar.gz</span></span>
<span class="line"><span>cd software</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 2. 配置（检查依赖、选择功能）</span></span>
<span class="line"><span>./configure --prefix=/usr/local --enable-feature-x</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 3. 编译</span></span>
<span class="line"><span>make -j$(nproc)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 4. 安装</span></span>
<span class="line"><span>sudo make install</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>其中 <code>./configure</code> 会生成 <code>Makefile</code>，<code>make</code> 按照它编译，<code>make install</code> 复制到系统目录3。</p></blockquote><h2 id="那为什么有些软件不用编译" tabindex="-1"><a class="header-anchor" href="#那为什么有些软件不用编译"><span>那为什么有些软件不用编译？</span></a></h2><ul><li>如果你用 <code>apt install</code>、<code>yum install</code>、<code>dnf install</code>，其实是安装了<strong>发行版维护者</strong>提前编译好的二进制包。</li><li>但如果这个软件<strong>没被打包</strong>，或者你需要<strong>特殊编译选项</strong>，就只能自己编译。</li></ul><h2 id="实用建议" tabindex="-1"><a class="header-anchor" href="#实用建议"><span>实用建议</span></a></h2><ul><li><strong>优先用包管理器</strong>（apt、yum、dnf、pacman），省时省心。</li><li><strong>需要定制或最新版本</strong> → 用源码编译。</li><li><strong>怕麻烦</strong> → 先找有没有别人打好的 <code>.deb</code>、<code>.rpm</code> 或 AppImage。</li><li><strong>频繁编译</strong> → 学会用 <code>checkinstall</code> 或 <code>stow</code> 管理源码安装，方便卸载和升级。</li></ul><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>在 Linux系统的世界里，没有唯一的“正确”安装方式，只有最适合当下需求的选择。 包管理器带来稳定与省心，源码编译赋予自由与性能，通用打包和容器化则让跨平台与隔离部署成为可能。掌握这些方法，就像掌握了多把钥匙——面对不同的系统环境与业务场景，你都能快速找到那一把最合适的，打开效率与稳定的大门。</p><p>写文不易，如果你都看到了这里，请点个赞和在看，分享给更多的朋友；也别忘了关注星哥玩云！这里有满满的干货分享，还有轻松有趣的技术交流～点个赞、分享给身边的小伙伴，一起成长，一起玩转技术世界吧！ 😊</p>`,67)]))}const c=s(l,[["render",d]]),o=JSON.parse('{"path":"/linux-basis2025/4.%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E8%A3%85%20Linux%20%E7%9A%84%E8%BD%AF%E4%BB%B6%EF%BC%8C%E7%BB%8F%E5%B8%B8%E8%A6%81%E7%BC%96%E8%AF%91.html","title":"为什么 Linux 装个软件还要自己编译？一文讲透背后的逻辑","lang":"en-US","frontmatter":{},"git":{"createdTime":1756914694000,"updatedTime":1756914694000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":1,"url":"https://github.com/star"}]},"readingTime":{"minutes":7.2,"words":2160},"filePathRelative":"linux-basis2025/4.为什么安装 Linux 的软件，经常要编译.md"}');export{c as comp,o as data};

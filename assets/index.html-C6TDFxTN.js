import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as e}from"./app-BiQR_lPj.js";const t={};function p(r,s){return e(),n("div",null,s[0]||(s[0]=[i(`<h1 id="解析web开发中的几种认证方法及应用场景" tabindex="-1"><a class="header-anchor" href="#解析web开发中的几种认证方法及应用场景"><span>解析Web开发中的几种认证方法及应用场景</span></a></h1><p>在Web开发中，认证是保障系统安全性的重要一环。不同的应用场景对认证方式的要求也不同。下面我们来详细介绍几种常见的认证方式。</p><p>本文是看了B站博主“IT老齐”的一个视频，算是一个笔记，再者星哥再去整合一些知识。</p><p><img src="https://imgoss.xgss.net/picgo/image-20250122155323565.png?aliyun" alt="image-20250122155323565"></p><h1 id="基本认证-basic-auth" tabindex="-1"><a class="header-anchor" href="#基本认证-basic-auth"><span>基本认证(Basic Auth)</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/image-20250122155419444.png?aliyun" alt="image-20250122155419444"></p><h2 id="basic-auth" tabindex="-1"><a class="header-anchor" href="#basic-auth"><span>Basic Auth</span></a></h2><p><strong>HTTP Basic Authentication（基本认证）</strong> 是一种简单的身份验证方法，广泛应用于一些对安全要求不高的场景，或者作为 Web 服务、API 之间通信的基本身份验证机制。</p><p>尽管存在安全隐患，但它因其实现简洁、配置简单，仍然在很多场景中得到了应用。</p><h2 id="在nginx中实现-basic-authentication" tabindex="-1"><a class="header-anchor" href="#在nginx中实现-basic-authentication"><span>在Nginx中实现 Basic Authentication</span></a></h2><h3 id="_1-生成-htpasswd-文件" tabindex="-1"><a class="header-anchor" href="#_1-生成-htpasswd-文件"><span>1.生成 .htpasswd 文件</span></a></h3><p>使用 htpasswd 工具生成用户名和密码的组合，并加密密码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>htpasswd -c /etc/nginx/.htpasswd user1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-配置-nginx" tabindex="-1"><a class="header-anchor" href="#_2-配置-nginx"><span>2.配置 Nginx</span></a></h3><p>在 Nginx 配置文件（通常是 /etc/nginx/nginx.conf 或相应的虚拟主机配置文件）中，添加以下配置来启用 Basic Authentication：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>server {</span></span>
<span class="line"><span>    listen 80;</span></span>
<span class="line"><span>    server_name example.com;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    location / {</span></span>
<span class="line"><span>        auth_basic &quot;Restricted Access&quot;;  # 提示信息</span></span>
<span class="line"><span>        auth_basic_user_file /etc/nginx/.htpasswd;  # 指定密码文件路径</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 其他配置</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-重启-nginx" tabindex="-1"><a class="header-anchor" href="#_3-重启-nginx"><span>3.重启 Nginx</span></a></h3><p>保存配置文件后，重启 Nginx 以使配置生效：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>sudo systemctl restart nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用浏览器打开站点，输入用户名密码</p><p><img src="https://imgoss.xgss.net/picgo/image-20250122162928935.png?aliyun" alt="image-20250122162928935"></p><p>如果输入错误则会显示401</p><p><img src="https://imgoss.xgss.net/picgo/image-20250122163158120.png?aliyun" alt="image-20250122163158120"></p><h1 id="令牌认证-token-auth" tabindex="-1"><a class="header-anchor" href="#令牌认证-token-auth"><span>令牌认证(Token Auth)</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/image-20250122155523019.png?aliyun" alt="image-20250122155523019"></p><h2 id="什么是令牌认证" tabindex="-1"><a class="header-anchor" href="#什么是令牌认证"><span>什么是令牌认证</span></a></h2><p>令牌认证是一种安全协议，通过使用加密令牌来验证用户的身份。与传统的用户名和密码相比，令牌认证提供了一个额外的安全层，可以更有效地保护用户的数据。</p><p>简单来说，令牌就像是一张通行证。 当你成功登录一个系统后，系统会给你颁发一个独特的令牌。这个令牌包含了你的身份信息，但它不是明文，而是经过加密的。在后续的请求中，你只需要携带这个令牌，系统就能识别你的身份，而不需要你每次都重新输入密码。</p><h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h2><ol><li><strong>用户登录：</strong> 用户输入用户名和密码进行登录。</li><li><strong>服务器验证：</strong> 服务器验证用户的身份信息。</li><li><strong>颁发令牌：</strong> 如果验证通过，服务器会生成一个令牌，并将其发送给客户端。</li><li><strong>客户端存储：</strong> 客户端将令牌存储起来，通常存储在本地存储或cookie中。</li><li><strong>后续请求：</strong> 客户端在后续的请求中将令牌包含在请求头中。</li><li><strong>服务器验证令牌：</strong> 服务器验证令牌的有效性，如果验证通过，则允许用户访问资源。</li></ol><h2 id="常见应用场景" tabindex="-1"><a class="header-anchor" href="#常见应用场景"><span>常见应用场景</span></a></h2><p>API接口认证： 保护API接口的安全，防止未授权访问。</p><p>单点登录： 用户只需登录一次，即可访问多个系统。</p><p>移动应用认证： 保护移动应用的数据安全。</p><h2 id="令牌的类型" tabindex="-1"><a class="header-anchor" href="#令牌的类型"><span>令牌的类型</span></a></h2><p>JWT（JSON Web Token）： 一种常用的令牌格式，它是一个自包含的、安全的、基于JSON的令牌。</p><p>OAuth 2.0： 一种授权框架，它允许第三方应用代表用户访问用户的资源。</p><p>SAML（Security Assertion Markup Language）： 一种基于XML的标准，用于在不同的安全域之间交换身份认证和授权数据。</p><h3 id="jwt-json-web-token" tabindex="-1"><a class="header-anchor" href="#jwt-json-web-token"><span>JWT（JSON Web Token）</span></a></h3><p>JWT (JSON Web Token) 是一种开放标准（RFC 7519），用于在网络上安全地传输信息的简洁、自包含的方式。它通常被用于身份验证和授权机制。</p><p>形象地说，JWT就像是一张通行证。当用户登录成功后，服务器会签发给用户一张通行证（即JWT），这张通行证包含了用户的一些基本信息，比如用户ID、用户名、角色等。用户在后续的请求中，只需携带这张通行证，就可以证明自己的身份，而不需要每次都重新登录。</p><h3 id="jwt-的结构" tabindex="-1"><a class="header-anchor" href="#jwt-的结构"><span>JWT 的结构</span></a></h3><p>一个 JWT 实际上是一个字符串，它由三部分组成，并用点（.）分隔：</p><p>头部（Header）： 包含了 metadata，比如 token 的类型（JWT）和所使用的签名算法。</p><p>载荷（Payload）： 包含了声明，例如，用户的 ID、用户名、以及过期时间等。</p><p>签名（Signature）： 签名是对前两部分内容的签名，用于验证消息的完整性。</p><p><img src="https://imgoss.xgss.net/picgo/image-20250122164522423.png?aliyun" alt="image-20250122164522423"></p><h1 id="oauth2-auth" tabindex="-1"><a class="header-anchor" href="#oauth2-auth"><span>OAuth2 Auth</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/image-20250122155703171.png?aliyun" alt="image-20250122155703171"></p><h2 id="什么是-oauth-2-0" tabindex="-1"><a class="header-anchor" href="#什么是-oauth-2-0"><span>什么是 OAuth 2.0</span></a></h2><p>OAuth 2.0 是一种授权框架，允许第三方应用程序在用户授权的情况下，访问用户在其他服务提供商（如 Google、Facebook）上的受保护资源。简单来说，就是让第三方应用能够代表用户执行一些操作，而无需直接获取用户的密码。</p><p>举个例子： 当你使用微信登录一个网站时，这个网站就是第三方应用，它通过 OAuth 2.0 向微信申请授权，获取你的部分个人信息，从而让你不用重新注册就可以登录这个网站。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h2><ol><li><strong>用户授权：</strong> 用户在客户端上发起授权请求，客户端将用户重定向到授权服务器。</li><li><strong>授权服务器验证：</strong> 授权服务器验证用户的身份。</li><li><strong>用户同意：</strong> 用户同意授权客户端访问其资源。</li><li><strong>授权服务器颁发授权码：</strong> 授权服务器颁发一个授权码给客户端。</li><li><strong>客户端获取访问令牌：</strong> 客户端使用授权码向授权服务器请求访问令牌。</li><li><strong>授权服务器颁发访问令牌：</strong> 授权服务器验证授权码后，颁发访问令牌给客户端。</li><li><strong>客户端访问资源：</strong> 客户端使用访问令牌向资源服务器请求资源。</li><li><strong>资源服务器验证：</strong> 资源服务器验证访问令牌的有效性，如果验证通过，则返回资源给客户端。</li></ol><h1 id="api-key-认证" tabindex="-1"><a class="header-anchor" href="#api-key-认证"><span>API KEY 认证</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/image-20250122155824722.png?aliyun" alt="image-20250122155824722"></p><h2 id="定义与原理" tabindex="-1"><a class="header-anchor" href="#定义与原理"><span>定义与原理</span></a></h2><p>API Key就像一个专门用来开启某个“特定房间”的钥匙，这个“特定房间”就是API，一个允许两个不同应用程序交流的桥梁。它是一个唯一的字符串，用于标识和验证API的用户。</p><p>当客户端向API发送请求时，需要在请求头中包含API Key，以证明其有权访问该API。服务器端收到请求后，会验证请求头中的API Key是否与存储在服务器端的密钥副本匹配，如果匹配，则认为请求是合法的，否则请求将被拒绝。</p><h2 id="实现步骤" tabindex="-1"><a class="header-anchor" href="#实现步骤"><span>实现步骤</span></a></h2><p>API Key认证的实现通常遵循以下步骤：</p><ol><li><strong>生成API Key</strong>：服务提供者为用户生成一个唯一的API Key，这个Key需要保密，不应在网络上明文传输。</li><li><strong>构建请求</strong>：客户端在发送请求时，需要在请求头或请求体中加入API Key。有时，为了增强安全性，还会结合其他信息（如请求的时间戳、请求路径等）生成一个签名，并将签名一同发送到服务器。</li><li><strong>验证API Key</strong>：服务器收到请求后，会验证请求头中的API Key或签名的有效性。如果API Key匹配或签名验证通过，则认为请求是合法的，否则请求将被拒绝。</li></ol><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h2><p>比如星哥使用的图床就是某云的对象存储，在控制台中申请KeyID和KeySecret，并且赋予访问权限之后，再通过id和secret就可以访问对应的对象存储，就实现了上传图片等功能。</p><p><img src="https://imgoss.xgss.net/picgo/image-20250122170553299.png?aliyun" alt="image-20250122170553299"></p><h1 id="四种认证方式的对比" tabindex="-1"><a class="header-anchor" href="#四种认证方式的对比"><span>四种认证方式的对比</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/token-yqd.jpg?aliyun" alt="token-yqd"></p><h1 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h1><p><img src="https://imgoss.xgss.net/picgo/image-20250122160738402.png?aliyun" alt="image-20250122160738402"></p><h2 id="basic-auth应用场景" tabindex="-1"><a class="header-anchor" href="#basic-auth应用场景"><span>Basic Auth应用场景</span></a></h2><ul><li>内部系统或测试环境，对安全性要求不高时的快速验证。</li><li>简单的web服务或API，尤其是在受信任的网络环境中。</li><li>内部管理系统登录，当组织有严格的安全网络和访问控制时。</li></ul><h2 id="token-auth应用场景" tabindex="-1"><a class="header-anchor" href="#token-auth应用场景"><span>Token Auth应用场景</span></a></h2><ul><li>RESTfuI API，特别是那些需要高性能和无状态性的场景。</li><li>移动应用和服务之间的通信，避免存储用户名和密码在客户端。</li><li>单点登录(SSO)解决方案的一部分，简化跨系统访问。</li></ul><h2 id="oauth-auth-应用场景" tabindex="-1"><a class="header-anchor" href="#oauth-auth-应用场景"><span>OAuth Auth 应用场景</span></a></h2><ul><li>社交媒体和第三方登录，如“使用Facebook/Google登录”</li><li>云服务和API的访问控制，如允许特定应用访问用户存储在云中的数据。</li><li>物联网(IoT)设备访问控制，确保设备安全地与云平台交互。</li></ul><h2 id="api-key-auth-应用场景" tabindex="-1"><a class="header-anchor" href="#api-key-auth-应用场景"><span>API KEY Auth 应用场景</span></a></h2><ul><li>企业级API管理，尤其是面向合作伙伴或客户的API，便于跟踪和控制使用情况数据</li><li>分析和聚合服务，客户通过API获取数据时认证。</li><li>内容分发网络(CDN)和API网关，用于简单的访问控制和流量监控，</li><li>第三方支付、调用天气API等</li></ul><h1 id="session-cookie-认证模式" tabindex="-1"><a class="header-anchor" href="#session-cookie-认证模式"><span>Session + Cookie 认证模式</span></a></h1><p>Session + Cookie 认证模式是一种传统的 Web 应用程序身份验证方式。它通过在服务器端创建 Session（会话）来跟踪用户的状态，并在客户端存储 Session ID（会话标识符）到 Cookie 中，从而实现用户身份的验证。</p><h2 id="工作原理-1" tabindex="-1"><a class="header-anchor" href="#工作原理-1"><span>工作原理</span></a></h2><ol><li>用户登录： 用户输入用户名和密码，服务器验证通过后，为该用户创建一个唯一的 Session。</li><li><strong>生成 Session ID：</strong> 服务器生成一个 Session ID，并将该 ID 与 Session 信息关联起来。</li><li><strong>设置 Cookie：</strong> 服务器将 Session ID 设置为一个 Cookie，发送给客户端。</li><li><strong>客户端存储 Cookie：</strong> 客户端的浏览器会将这个 Cookie 保存起来。</li><li><strong>后续请求：</strong> 每次客户端向服务器发送请求时，浏览器都会自动将这个 Cookie 发送给服务器。</li><li><strong>服务器验证 Session：</strong> 服务器根据 Cookie 中的 Session ID 找到对应的 Session，验证用户身份。</li></ol><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h2><p>session信息需要额外的数据库存储，例如一般需增加redis、memached等应用。在多机负载时，需要考虑session共享；</p><p><strong>简单易懂：</strong> 实现相对简单，易于理解。</p><p><strong>广泛支持：</strong> 大多数 Web 服务器和编程语言都支持 Session。</p><p><strong>状态保持：</strong> 可以方便地存储用户的状态信息，如购物车、登录状态等。</p><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h2><p>session信息统一管理，可以在服务端统一控制认证的过期时间或个别用户的过期时间。</p><p><strong>状态维护：</strong> 服务器需要维护大量的 Session，占用服务器资源。</p><p><strong>跨域问题：</strong> 跨域请求时，Cookie 不能自动发送，需要额外的处理。</p><p><strong>安全性问题：</strong> Cookie 存储在客户端，容易被篡改或窃取。</p><p><strong>负载均衡：</strong> 在分布式系统中，Session 的共享和同步比较复杂。</p><h1 id="结尾" tabindex="-1"><a class="header-anchor" href="#结尾"><span>结尾</span></a></h1><p>在Web开发中，选择合适的认证方式对于保护用户隐私和资源安全至关重要。不同的认证方式具有不同的优缺点和适用场景。因此，在开发过程中，需要根据具体需求和场景来选择合适的认证方式，并采取相应的安全措施来确保认证过程的安全性和可靠性。</p>`,94)]))}const o=a(t,[["render",p]]),c=JSON.parse('{"path":"/article/x3c9re75/","title":"WEB开发中的几种认证的方式","lang":"en-US","frontmatter":{"title":"WEB开发中的几种认证的方式","createTime":"2025/05/27 17:51:17","permalink":"/article/x3c9re75/"},"git":{"createdTime":1749111496000,"updatedTime":1750129445000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":2,"url":"https://github.com/star"}]},"readingTime":{"minutes":9.82,"words":2946},"filePathRelative":"linux-basis/WEB开发中的几种认证的方式.md"}');export{o as comp,c as data};

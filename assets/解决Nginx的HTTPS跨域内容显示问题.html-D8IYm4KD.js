import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-BiQR_lPj.js";const l={};function p(r,s){return i(),e("div",null,s[0]||(s[0]=[a(`<h1 id="解决nginx的https跨域内容显示问题" tabindex="-1"><a class="header-anchor" href="#解决nginx的https跨域内容显示问题"><span>解决Nginx的HTTPS跨域内容显示问题</span></a></h1><h2 id="遇到的问题" tabindex="-1"><a class="header-anchor" href="#遇到的问题"><span>遇到的问题</span></a></h2><p>最近星哥遇到一个问题就是</p><p>A域名、B域名同时记录解析到1.1.1.1服务器中</p><p>A域名配置了http和https</p><p>B域名配置了http，没有配置https</p><p>问题： B域名使用https访问，能看到A域名的内容</p><p>最简单的方法是把B域名也配置一个HTTPS的站点，但是因为B域名没有证书或者不需要https。</p><h2 id="可能的原因" tabindex="-1"><a class="header-anchor" href="#可能的原因"><span>可能的原因：</span></a></h2><p>当通过 HTTPS 访问 B 域名时，却显示了 A 域名的内容。这通常是因为 Nginx 在处理 B 域名的 HTTPS 请求时，找不到匹配的 HTTPS 服务器块，从而退回（fallback）到默认的（或第一个配置的）HTTPS 服务器块，而这个服务器块恰好是 A 域名的。</p><p><img src="https://imgoss.xgss.net/picgo-tx2025/image-20250730170843227.png?tx" alt="image-20250730170843227"></p><h1 id="配置默认https-服务器块" tabindex="-1"><a class="header-anchor" href="#配置默认https-服务器块"><span>配置默认HTTPS 服务器块</span></a></h1><p>配置为服务器配置一个默认的 HTTPS 服务器块</p><p>如果您的服务器上托管了多个域名，并且希望确保任何对未知或未配置 HTTPS 域名的请求都不会落入其他域名的内容，这是一种更健壮的方法。</p><h2 id="自签名证书" tabindex="-1"><a class="header-anchor" href="#自签名证书"><span>自签名证书</span></a></h2><h3 id="步骤一-生成私钥" tabindex="-1"><a class="header-anchor" href="#步骤一-生成私钥"><span>步骤一：生成私钥</span></a></h3><p>首先，需要为您的证书生成一个私钥。这个私钥将用于加密和解密数据，并且应该妥善保管，切勿泄露。</p><p>在终端中运行以下命令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>cd /etc/nginx/ssl/</span></span>
<span class="line"><span>openssl genrsa -out default_server.key 2048</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><p>openssl genrsa: 这是 OpenSSL 中用于生成 RSA 私钥的命令。</p><p>-out default_server.key: 指定输出文件的名称。请将 default_server.key 替换为您的实际域名（例如 example.com.key），这样更容易识别。</p><p>2048: 指定私钥的长度为 2048 位，这是一个常用的安全长度。</p><p>执行此命令后，会在当前目录下生成一个名为 default_server.key 的文件，这就是您的私钥。</p><h3 id="步骤二-生成证书签名请求-csr" tabindex="-1"><a class="header-anchor" href="#步骤二-生成证书签名请求-csr"><span>步骤二：生成证书签名请求 (CSR)</span></a></h3><p>接下来，您需要生成一个证书签名请求 (CSR)。CSR 包含了您的公钥以及一些关于您的组织和域名的信息。通常，当您向 CA 申请证书时，您会把这个 CSR 发给他们。但在自签名的情况下，我们会用它来创建自己的证书。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>openssl req -new -key default_server.key -out default_server.csr</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>解释：</p><ul><li><code>openssl req</code>: 这是 OpenSSL 中用于生成 CSR 和管理证书的命令。</li><li><code>-new</code>: 表示生成一个新的 CSR。</li><li><code>-key default_server.key</code>: 指定使用上一步生成的私钥。</li><li><code>-out default_server.csr</code>: 指定输出 CSR 文件的名称。</li></ul><p>执行此命令后，系统会提示您输入一些信息，这些信息将包含在您的证书中。请注意以下几点：</p><p>可以不用输入信息，全部回车。</p><ul><li><strong>Common Name (CN)</strong>：这是最重要的一项。对于服务器证书，这里应该输入您的<strong>域名</strong>（例如 <code>example.com</code> 或 <code>www.example.com</code>）。如果您打算将此证书用于 IP 地址，则输入 IP 地址。如果用于多个域名，则需要一个支持 SAN (Subject Alternative Name) 的证书，这在基本自签名中不直接支持，但可以通过配置文件实现更复杂的自签名。</li><li><strong>Organization Name (O)</strong>, <strong>Organization Unit (OU)</strong>, <strong>Locality (L)</strong>, <strong>State or Province (ST)</strong>, <strong>Country Name (C)</strong>：这些是可选的组织信息。</li><li><strong>Email Address</strong>：可选。</li><li><strong>A challenge password / An optional company name</strong>: 这些可以留空，通常在自签名证书中不需要。</li></ul><p>填写完毕后，会在当前目录下生成一个名为 default_server.csr\` 的文件。</p><h3 id="步骤三-自签名证书" tabindex="-1"><a class="header-anchor" href="#步骤三-自签名证书"><span>步骤三：自签名证书</span></a></h3><p>最后一步是使用您自己的私钥来“签名”您刚刚生成的 CSR，从而创建自签名证书。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>openssl x509 -req -days 365 -in default_server.csr -signkey default_server.key -out default_server.crt</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>openssl x509</code>: 这是 OpenSSL 中用于处理 X.509 证书的命令。</li><li><code>-req</code>: 表示输入的是一个 CSR。</li><li><code>-days 365</code>: 指定证书的有效期为 365 天。您可以根据需要调整这个数字。</li><li><code>-in default_server.csr</code>: 指定使用上一步生成的 CSR 文件。</li><li><code>-signkey default_server.key</code>: 指定用于签名的私钥，这里就是您自己的私钥。</li><li><code>-out default_server.crt</code>: 指定输出证书文件的名称。通常以 <code>.crt</code> 结尾。</li></ul><p>执行此命令后，您会在当前目录下得到一个名为 default_server.crt\` 的文件，这就是您的<strong>自签名证书</strong>！</p><h2 id="配置nginx" tabindex="-1"><a class="header-anchor" href="#配置nginx"><span>配置nginx</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>server {</span></span>
<span class="line"><span>    listen 443 ssl default_server;</span></span>
<span class="line"><span>    server_name _; # 捕获所有未匹配的域名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 使用一个虚拟证书或通用证书</span></span>
<span class="line"><span>    ssl_certificate /etc/nginx/ssl/default_server.crt; # 虚拟或自签名证书的路径</span></span>
<span class="line"><span>    ssl_certificate_key /etc/nginx/ssl/default_server.key; # 虚拟或自签名密钥的路径</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 返回 444（无响应）或重定向到 HTTP</span></span>
<span class="line"><span>    return 444; # 关闭连接而不发送任何响应</span></span>
<span class="line"><span>    # 或者重定向到通用的 HTTP 页面，或者直接拒绝</span></span>
<span class="line"><span>    # return 301 http://$host$request_uri;</span></span>
<span class="line"><span>    # deny all;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 您的 A 域名现有 HTTPS 配置</span></span>
<span class="line"><span>server {</span></span>
<span class="line"><span>    listen 443 ssl;</span></span>
<span class="line"><span>    server_name A.com www.A.com; # 将 A.com 替换为您的实际 A 域名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ssl_certificate /etc/nginx/ssl/A.com.crt;</span></span>
<span class="line"><span>    ssl_certificate_key /etc/nginx/ssl/A.com.key;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 您的 A 域名 HTTPS 内容配置</span></span>
<span class="line"><span>    root /var/www/A.com;</span></span>
<span class="line"><span>    index index.html;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 您的 B 域名现有 HTTP 配置</span></span>
<span class="line"><span>server {</span></span>
<span class="line"><span>    listen 80;</span></span>
<span class="line"><span>    server_name B.com www.B.com; # 将 B.com 替换为您的实际 B 域名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    root /var/www/B.com;</span></span>
<span class="line"><span>    index index.html;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 您的 A 域名现有 HTTP 配置（如果有的话）</span></span>
<span class="line"><span>server {</span></span>
<span class="line"><span>    listen 80;</span></span>
<span class="line"><span>    server_name A.com www.A.com;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    root /var/www/A.com;</span></span>
<span class="line"><span>    index index.html;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解释：</strong></p><ul><li><code>listen 443 ssl</code> 行上的 <code>default_server</code> 指令使得这个服务器块成为任何未匹配其他 <code>server_name</code> 的 443 端口 HTTPS 请求的<strong>备用</strong>。</li><li><code>server_name _;</code> 是表示捕获所有未匹配域名的常用方式（它永远不会匹配真实的域名）。</li><li><code>return 444;</code> 是 Nginx 特定的状态码，它会关闭连接而不向客户端发送任何响应。这对于阻止不必要的流量非常有用。或者，您可以使用 <code>deny all;</code> 或像方案一那样进行重定向。</li><li>您<strong>必须</strong>为这个默认的 HTTPS 块提供 <code>ssl_certificate</code> 和 <code>ssl_certificate_key</code>，以便 Nginx 可以完成 SSL 握手。在这里使用自签名或虚拟证书是完全可以的，它的目的只是为了捕获未配置的 HTTPS 请求。</li></ul><h1 id="省流版" tabindex="-1"><a class="header-anchor" href="#省流版"><span>省流版</span></a></h1><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>生成证书：</span></span>
<span class="line"><span>cd /etc/nginx/ssl/</span></span>
<span class="line"><span>openssl genrsa -out default_server.key 2048</span></span>
<span class="line"><span>openssl req -new -key default_server.key -out default_server.csr</span></span>
<span class="line"><span>openssl x509 -req -days 3650 -in default_server.csr -signkey default_server.key -out default_server.crt</span></span>
<span class="line"><span></span></span>
<span class="line"><span>server {</span></span>
<span class="line"><span>    listen 443 ssl default_server;</span></span>
<span class="line"><span>    server_name _; # 捕获所有未匹配的域名</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 使用一个虚拟证书或通用证书</span></span>
<span class="line"><span>    ssl_certificate /etc/nginx/ssl/default_server.crt; # 虚拟或自签名证书的路径</span></span>
<span class="line"><span>    ssl_certificate_key /etc/nginx/ssl/default_server.key; # 虚拟或自签名密钥的路径</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 返回 444（无响应）或重定向到 HTTP</span></span>
<span class="line"><span>    return 444; # 关闭连接而不发送任何响应</span></span>
<span class="line"><span>    # 或者重定向到通用的 HTTP 页面，或者直接拒绝</span></span>
<span class="line"><span>    # return 301 http://$host$request_uri;</span></span>
<span class="line"><span>    # deny all;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看证书</p><p><img src="https://imgoss.xgss.net/picgo-tx2025/QQ_1753862473287.png?tx" alt="img"></p>`,46)]))}const t=n(l,[["render",p]]),v=JSON.parse('{"path":"/nginx/%E8%A7%A3%E5%86%B3Nginx%E7%9A%84HTTPS%E8%B7%A8%E5%9F%9F%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98.html","title":"解决Nginx的HTTPS跨域内容显示问题","lang":"en-US","frontmatter":{},"git":{"createdTime":1754468658000,"updatedTime":1754468658000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":1,"url":"https://github.com/star"}]},"readingTime":{"minutes":5.41,"words":1624},"filePathRelative":"nginx/解决Nginx的HTTPS跨域内容显示问题.md"}');export{t as comp,v as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as r}from"./app-BiQR_lPj.js";const o={};function s(d,a){return r(),t("div",null,a[0]||(a[0]=[n('<h1 id="从100到511的这些数字-http状态码背后的秘密你知道多少" tabindex="-1"><a class="header-anchor" href="#从100到511的这些数字-http状态码背后的秘密你知道多少"><span>从100到511的这些数字，HTTP状态码背后的秘密你知道多少？</span></a></h1><h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>每次你在浏览器输入网址，背后都有一场与服务器的&quot;沉默对话&quot;。当你看到页面正常加载时，这场对话顺畅愉快；当出现&quot;无法访问&quot;时，其实是服务器给你发了一封&quot;出错通知书&quot;——这就是<strong>HTTP响应状态码</strong>，互联网世界的&quot;表情语言&quot;。</p><p>作为开发者，理解这些三位数字的含义不仅能帮你快速定位问题，更能让你写出更健壮的程序。今天我们就来系统解读HTTP状态码的五大类60+成员，从最常见的200、404到冷知识418，一篇文章全部掌握！</p><p><img src="https://imgoss.xgss.net/picgo-tx2025/QQ_1752060192898.png?tx" alt="img"></p><h2 id="状态码分类总览-数字背后的秘密" tabindex="-1"><a class="header-anchor" href="#状态码分类总览-数字背后的秘密"><span>状态码分类总览：数字背后的秘密</span></a></h2><p>HTTP状态码由三位数字组成，第一位数字定义了响应的类别，后两位没有分类作用。五大类状态码如下：</p><table><thead><tr><th>类别</th><th>范围</th><th>含义</th><th>常见场景</th></tr></thead><tbody><tr><td><strong>信息响应</strong></td><td>100-199</td><td>请求已接收，继续处理</td><td>大文件上传、协议切换</td></tr><tr><td><strong>成功响应</strong></td><td>200-299</td><td>请求已成功处理</td><td>页面正常加载、API调用成功</td></tr><tr><td><strong>重定向消息</strong></td><td>300-399</td><td>需要进一步操作以完成请求</td><td>网页搬家、资源跳转</td></tr><tr><td><strong>客户端错误</strong></td><td>400-499</td><td>请求有错误，服务器无法处理</td><td>地址错误、权限不足</td></tr><tr><td><strong>服务端错误</strong></td><td>500-599</td><td>服务器处理请求时出错</td><td>代码bug、服务器过载</td></tr></tbody></table><blockquote><p>💡 <strong>冷知识</strong>：状态码是HTTP/1.0规范中首次定义的，1996年发布的RFC 1945文档确立了最初的状态码体系。</p></blockquote><h2 id="一、信息响应-1xx" tabindex="-1"><a class="header-anchor" href="#一、信息响应-1xx"><span>一、信息响应（1xx）</span></a></h2><h3 id="_100-continue" tabindex="-1"><a class="header-anchor" href="#_100-continue"><span>100 Continue</span></a></h3><p>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p><h3 id="_101-switching-protocols" tabindex="-1"><a class="header-anchor" href="#_101-switching-protocols"><span>101 Switching Protocols</span></a></h3><p>该代码是响应客户端的 Upgrade 请求头发送的，指明服务器即将切换的协议。</p><h3 id="_102-processing-webdav" tabindex="-1"><a class="header-anchor" href="#_102-processing-webdav"><span>102 Processing (WebDAV)</span></a></h3><p>此代码表示服务器已收到并正在处理该请求，但当前没有响应可用。</p><h3 id="_103-early-hints" tabindex="-1"><a class="header-anchor" href="#_103-early-hints"><span>103 Early Hints</span></a></h3><p>此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器准备响应阶段时开始预加载 preloading 资源。</p><h2 id="二、成功响应-2xx-服务器的-ok-手势" tabindex="-1"><a class="header-anchor" href="#二、成功响应-2xx-服务器的-ok-手势"><span>二、成功响应（2xx）：服务器的&quot;OK&quot;手势</span></a></h2><p>这是开发者最希望看到的状态码，代表一切正常。</p><h3 id="_200-ok-万事大吉" tabindex="-1"><a class="header-anchor" href="#_200-ok-万事大吉"><span>200 OK：万事大吉</span></a></h3><p><strong>含义</strong>：请求成功处理并返回数据<br><strong>场景</strong>：</p><ul><li>GET请求：资源已提取并在响应中返回</li><li>POST请求：数据已提交成功</li><li>HEAD请求：仅返回响应头，无响应体</li></ul><p><strong>开发提示</strong>：虽然200表示成功，但在API设计中建议配合明确的响应体说明，如<code>{&quot;status&quot;:&quot;success&quot;,&quot;data&quot;:{}}</code></p><h3 id="_201-created-新资源诞生" tabindex="-1"><a class="header-anchor" href="#_201-created-新资源诞生"><span>201 Created：新资源诞生</span></a></h3><p><strong>含义</strong>：请求成功并创建了新资源<br><strong>典型场景</strong>：</p><ul><li>POST提交表单创建新用户</li><li>上传文件成功</li></ul><p><strong>特别说明</strong>：响应应包含<code>Location</code>头，指向新创建资源的URL，如<code>Location: /users/123</code></p><h3 id="_203-non-authoritative-information" tabindex="-1"><a class="header-anchor" href="#_203-non-authoritative-information"><span>203 Non-Authoritative Information</span></a></h3><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p><h3 id="_204-no-content-成功但-无话可说" tabindex="-1"><a class="header-anchor" href="#_204-no-content-成功但-无话可说"><span>204 No Content：成功但&quot;无话可说&quot;</span></a></h3><p><strong>含义</strong>：请求成功处理，但没有返回内容<br><strong>最佳实践</strong>：</p><ul><li>DELETE操作成功后</li><li>PUT更新资源但无需返回新内容</li></ul><blockquote><p>🌟 <strong>实用技巧</strong>：前端可以根据204状态码直接刷新列表，无需处理响应体</p></blockquote><h3 id="_205-reset-content" tabindex="-1"><a class="header-anchor" href="#_205-reset-content"><span>205 Reset Content</span></a></h3><p>告诉用户代理重置发送此请求的文档。</p><h3 id="_206-partial-content" tabindex="-1"><a class="header-anchor" href="#_206-partial-content"><span>206 Partial Content</span></a></h3><p>当从客户端发送Range范围标头以只请求资源的一部分时，将使用此响应代码。</p><h3 id="_207-multi-status-webdav" tabindex="-1"><a class="header-anchor" href="#_207-multi-status-webdav"><span>207 Multi-Status (WebDAV)</span></a></h3><p>对于多个状态代码都可能合适的情况，传输有关多个资源的信息。</p><h3 id="_208-already-reported-webdav" tabindex="-1"><a class="header-anchor" href="#_208-already-reported-webdav"><span>208 Already Reported (WebDAV)</span></a></h3><p>在 DAV 里面使用 <a href="dav:propstat" target="_blank" rel="noopener noreferrer">dav:propstat</a> 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。</p><h3 id="_226-im-used-http-delta-encoding" tabindex="-1"><a class="header-anchor" href="#_226-im-used-http-delta-encoding"><span>226 IM Used (HTTP Delta encoding)</span></a></h3><p>服务器已经完成了对资源的GET请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</p><h2 id="三、重定向-3xx-互联网的-指路牌" tabindex="-1"><a class="header-anchor" href="#三、重定向-3xx-互联网的-指路牌"><span>三、重定向（3xx）：互联网的&quot;指路牌&quot;</span></a></h2><p>这类状态码告诉客户端：&quot;你要的东西不在这里，往那边走！&quot;</p><h3 id="_301-moved-permanently-永久搬家" tabindex="-1"><a class="header-anchor" href="#_301-moved-permanently-永久搬家"><span>301 Moved Permanently：永久搬家</span></a></h3><p><strong>含义</strong>：请求的资源已永久移动到新位置<br><strong>SEO影响</strong>：搜索引擎会更新索引，将旧URL替换为新URL<br><strong>适用场景</strong>：</p><ul><li>网站域名更换</li><li>页面永久迁移</li></ul><p><strong>注意</strong>：客户端后续请求应使用新URL，旧地址可能不再有效</p><h3 id="_302-found-vs-307-temporary-redirect-临时绕道" tabindex="-1"><a class="header-anchor" href="#_302-found-vs-307-temporary-redirect-临时绕道"><span>302 Found vs 307 Temporary Redirect：临时绕道</span></a></h3><p>这两个状态码容易混淆，关键区别在于<strong>是否允许改变请求方法</strong>：</p><table><thead><tr><th>状态码</th><th>特点</th><th>实际行为</th></tr></thead><tbody><tr><td>302 Found</td><td>标准重定向</td><td>浏览器可能将POST改为GET</td></tr><tr><td>307 Temporary Redirect</td><td>严格重定向</td><td>必须保持原请求方法</td></tr></tbody></table><p><strong>建议</strong>：API开发中优先使用307，避免方法被意外转换</p><h3 id="_303-see-other" tabindex="-1"><a class="header-anchor" href="#_303-see-other"><span>303 See Other</span></a></h3><p>服务器发送此响应，以指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源。</p><h3 id="_304-not-modified-缓存的-省钱之道" tabindex="-1"><a class="header-anchor" href="#_304-not-modified-缓存的-省钱之道"><span>304 Not Modified：缓存的&quot;省钱之道&quot;</span></a></h3><p><strong>含义</strong>：资源未修改，可使用本地缓存<br><strong>工作原理</strong>：</p><ol><li>客户端第一次请求时，服务器返回资源和<code>Last-Modified</code>/<code>ETag</code>头</li><li>再次请求时，客户端发送<code>If-Modified-Since</code>/<code>If-None-Match</code>头</li><li>服务器对比后发现未修改，返回304，不传输资源内容</li></ol><blockquote><p>⚡ <strong>性能优化</strong>：合理利用304可减少50%以上的带宽消耗</p></blockquote><h3 id="_305-use-proxy-已弃用" tabindex="-1"><a class="header-anchor" href="#_305-use-proxy-已弃用"><span>305 Use Proxy 已弃用</span></a></h3><p>在 HTTP 规范中定义，以指示请求的响应必须被代理访问。由于对代理的带内配置的安全考虑，它已被弃用。</p><h3 id="_306-unused" tabindex="-1"><a class="header-anchor" href="#_306-unused"><span>306 unused</span></a></h3><p>此响应代码不再使用；它只是保留。它曾在 HTTP/1.1 规范的早期版本中使用过。</p><h3 id="_307-temporary-redirect" tabindex="-1"><a class="header-anchor" href="#_307-temporary-redirect"><span>307 Temporary Redirect</span></a></h3><p>服务器发送此响应，以指示客户端使用在前一个请求中使用的相同方法在另一个 URI 上获取所请求的资源。这与 302 Found HTTP 响应代码具有相同的语义，但用户代理 不能 更改所使用的 HTTP 方法：如果在第一个请求中使用了 POST，则在第二个请求中必须使用 POST</p><h3 id="_308-permanent-redirect" tabindex="-1"><a class="header-anchor" href="#_308-permanent-redirect"><span>308 Permanent Redirect</span></a></h3><p>这意味着资源现在永久位于由Location: HTTP Response 标头指定的另一个 URI。这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。</p><h2 id="四、客户端错误-4xx-是你的问题" tabindex="-1"><a class="header-anchor" href="#四、客户端错误-4xx-是你的问题"><span>四、客户端错误（4xx）：&quot;是你的问题&quot;</span></a></h2><p>这类错误码表示客户端发送的请求有问题，服务器无法处理。</p><h3 id="_400-bad-request-请求-语法错误" tabindex="-1"><a class="header-anchor" href="#_400-bad-request-请求-语法错误"><span>400 Bad Request：请求&quot;语法错误&quot;</span></a></h3><p><strong>含义</strong>：服务器无法理解请求格式<br><strong>常见原因</strong>：</p><ul><li>JSON格式错误</li><li>参数缺失或格式不正确</li><li>URL包含非法字符</li></ul><p><strong>解决方法</strong>：检查请求头、参数格式和编码</p><h3 id="_401-unauthorized-vs-403-forbidden-权限的-两道门槛" tabindex="-1"><a class="header-anchor" href="#_401-unauthorized-vs-403-forbidden-权限的-两道门槛"><span>401 Unauthorized vs 403 Forbidden：权限的&quot;两道门槛&quot;</span></a></h3><p>这对&quot;兄弟码&quot;常被混淆，核心区别在于<strong>认证状态</strong>：</p><table><thead><tr><th>状态码</th><th>含义</th><th>典型场景</th></tr></thead><tbody><tr><td>401</td><td><strong>未认证</strong>：需要登录</td><td>未登录用户访问需授权页面</td></tr><tr><td>403</td><td><strong>已认证但无权限</strong>：服务器拒绝访问</td><td>普通用户尝试访问管理员后台</td></tr></tbody></table><blockquote><p>🔒 <strong>安全实践</strong>：403错误不应透露资源是否存在，避免信息泄露</p></blockquote><h3 id="_402-payment-required-实验性" tabindex="-1"><a class="header-anchor" href="#_402-payment-required-实验性"><span>402 Payment Required 实验性</span></a></h3><p>此响应代码保留供将来使用。创建此代码的最初目的是将其用于数字支付系统，但是此状态代码很少使用，并且不存在标准约定。</p><h3 id="_403-forbidden" tabindex="-1"><a class="header-anchor" href="#_403-forbidden"><span>403 Forbidden</span></a></h3><p>客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 401 Unauthorized 不同，服务器知道客户端的身份。</p><h3 id="_404-not-found-互联网的-寻人启事" tabindex="-1"><a class="header-anchor" href="#_404-not-found-互联网的-寻人启事"><span>404 Not Found：互联网的&quot;寻人启事&quot;</span></a></h3><p><strong>含义</strong>：服务器找不到请求的资源<br><strong>可能原因</strong>：</p><ul><li>URL拼写错误</li><li>资源已被删除</li><li>权限不足（服务器伪装成404）</li></ul><p><strong>用户体验建议</strong>：自定义404页面，提供导航链接和搜索框</p><h3 id="_405-method-not-allowed" tabindex="-1"><a class="header-anchor" href="#_405-method-not-allowed"><span>405 Method Not Allowed</span></a></h3><p>服务器知道请求方法，但目标资源不支持该方法。例如，API 可能不允许调用DELETE来删除资源。</p><h3 id="_406-not-acceptable" tabindex="-1"><a class="header-anchor" href="#_406-not-acceptable"><span>406 Not Acceptable</span></a></h3><p>当 web 服务器在执行服务端驱动型内容协商机制后，没有发现任何符合用户代理给定标准的内容时，就会发送此响应。</p><h3 id="_407-proxy-authentication-required" tabindex="-1"><a class="header-anchor" href="#_407-proxy-authentication-required"><span>407 Proxy Authentication Required</span></a></h3><p>类似于 401 Unauthorized 但是认证需要由代理完成。</p><h3 id="_408-request-timeout" tabindex="-1"><a class="header-anchor" href="#_408-request-timeout"><span>408 Request Timeout</span></a></h3><p>此响应由一些服务器在空闲连接上发送，即使客户端之前没有任何请求。这意味着服务器想关闭这个未使用的连接。由于一些浏览器，如 Chrome、Firefox 27+ 或 IE9，使用 HTTP 预连接机制来加速冲浪，所以这种响应被使用得更多。还要注意的是，有些服务器只是关闭了连接而没有发送此消息。</p><h3 id="_409-conflict" tabindex="-1"><a class="header-anchor" href="#_409-conflict"><span>409 Conflict</span></a></h3><p>当请求与服务器的当前状态冲突时，将发送此响应。</p><h3 id="_410-gone" tabindex="-1"><a class="header-anchor" href="#_410-gone"><span>410 Gone</span></a></h3><p>当请求的内容已从服务器中永久删除且没有转发地址时，将发送此响应。客户端需要删除缓存和指向资源的链接。HTTP 规范打算将此状态代码用于“有限时间的促销服务”。API 不应被迫指出已使用此状态代码删除的资源。</p><h3 id="_411-length-required" tabindex="-1"><a class="header-anchor" href="#_411-length-required"><span>411 Length Required</span></a></h3><p>服务端拒绝该请求因为 Content-Length 头部字段未定义但是服务端需要它。</p><h3 id="_412-precondition-failed" tabindex="-1"><a class="header-anchor" href="#_412-precondition-failed"><span>412 Precondition Failed</span></a></h3><p>客户端在其头文件中指出了服务器不满足的先决条件。</p><h3 id="_413-payload-too-large" tabindex="-1"><a class="header-anchor" href="#_413-payload-too-large"><span>413 Payload Too Large</span></a></h3><p>请求实体大于服务器定义的限制。服务器可能会关闭连接，或在标头字段后返回重试 Retry-After。</p><h3 id="_414-uri-too-long" tabindex="-1"><a class="header-anchor" href="#_414-uri-too-long"><span>414 URI Too Long</span></a></h3><p>客户端请求的 URI 比服务器愿意接收的长度长。</p><h3 id="_415-unsupported-media-type" tabindex="-1"><a class="header-anchor" href="#_415-unsupported-media-type"><span>415 Unsupported Media Type</span></a></h3><p>服务器不支持请求数据的媒体格式，因此服务器拒绝请求。</p><h3 id="_416-range-not-satisfiable" tabindex="-1"><a class="header-anchor" href="#_416-range-not-satisfiable"><span>416 Range Not Satisfiable</span></a></h3><p>无法满足请求中 Range 标头字段指定的范围。该范围可能超出了目标 URI 数据的大小。</p><h3 id="_417-expectation-failed" tabindex="-1"><a class="header-anchor" href="#_417-expectation-failed"><span>417 Expectation Failed</span></a></h3><p>此响应代码表示服务器无法满足 Expect 请求标头字段所指示的期望。</p><h3 id="_418-i-m-a-teapot" tabindex="-1"><a class="header-anchor" href="#_418-i-m-a-teapot"><span>418 I&#39;m a teapot</span></a></h3><p>服务端拒绝用茶壶煮咖啡。笑话，典故来源茶壶冲泡咖啡</p><h3 id="_421-misdirected-request" tabindex="-1"><a class="header-anchor" href="#_421-misdirected-request"><span>421 Misdirected Request</span></a></h3><p>请求被定向到无法生成响应的服务器。这可以由未配置为针对请求 URI 中包含的方案和权限组合生成响应的服务器发送。</p><h3 id="_422-unprocessable-entity-webdav" tabindex="-1"><a class="header-anchor" href="#_422-unprocessable-entity-webdav"><span>422 Unprocessable Entity (WebDAV)</span></a></h3><p>请求格式正确，但由于语义错误而无法遵循。</p><h3 id="_423-locked-webdav" tabindex="-1"><a class="header-anchor" href="#_423-locked-webdav"><span>423 Locked (WebDAV)</span></a></h3><p>正在访问的资源已锁定。</p><h3 id="_424-failed-dependency-webdav" tabindex="-1"><a class="header-anchor" href="#_424-failed-dependency-webdav"><span>424 Failed Dependency (WebDAV)</span></a></h3><p>由于前一个请求失败，请求失败。</p><h3 id="_425-too-early-实验性" tabindex="-1"><a class="header-anchor" href="#_425-too-early-实验性"><span>425 Too Early 实验性</span></a></h3><p>表示服务器不愿意冒险处理可能被重播的请求。</p><h3 id="_426-upgrade-required" tabindex="-1"><a class="header-anchor" href="#_426-upgrade-required"><span>426 Upgrade Required</span></a></h3><p>服务器拒绝使用当前协议执行请求，但在客户端升级到其他协议后可能愿意这样做。 服务端发送带有Upgrade 字段的 426 响应 来表明它所需的协议（们）。</p><h3 id="_428-precondition-required" tabindex="-1"><a class="header-anchor" href="#_428-precondition-required"><span>428 Precondition Required</span></a></h3><p>源服务器要求请求是有条件的。此响应旨在防止&#39;丢失更新&#39;问题，即当第三方修改服务器上的状态时，客户端 GET 获取资源的状态，对其进行修改并将其 PUT 放回服务器，从而导致冲突。</p><h3 id="_429-too-many-requests" tabindex="-1"><a class="header-anchor" href="#_429-too-many-requests"><span>429 Too Many Requests</span></a></h3><p>用户在给定的时间内发送了太多请求（&quot;限制请求速率&quot;）</p><h3 id="_431-request-header-fields-too-large" tabindex="-1"><a class="header-anchor" href="#_431-request-header-fields-too-large"><span>431 Request Header Fields Too Large</span></a></h3><p>服务器不愿意处理请求，因为其头字段太大。在减小请求头字段的大小后，可以重新提交请求。</p><h3 id="_451-unavailable-for-legal-reasons" tabindex="-1"><a class="header-anchor" href="#_451-unavailable-for-legal-reasons"><span>451 Unavailable For Legal Reasons</span></a></h3><p>用户代理请求了无法合法提供的资源，例如政府审查的网页。</p><h2 id="五、服务器错误-5xx-是我的问题" tabindex="-1"><a class="header-anchor" href="#五、服务器错误-5xx-是我的问题"><span>五、服务器错误（5xx）：&quot;是我的问题&quot;</span></a></h2><p>当看到这类状态码，通常不是你的错，是服务器&quot;闹脾气&quot;了。</p><h3 id="_500-internal-server-error-服务器的-蓝屏" tabindex="-1"><a class="header-anchor" href="#_500-internal-server-error-服务器的-蓝屏"><span>500 Internal Server Error：服务器的&quot;蓝屏&quot;</span></a></h3><p><strong>含义</strong>：服务器遇到意外错误，无法完成请求<br><strong>可能原因</strong>：</p><ul><li>代码bug（最常见）</li><li>数据库连接失败</li><li>内存溢出</li></ul><p><strong>排查方向</strong>：检查服务器日志 &gt; 复现问题 &gt; 修复代码</p><h3 id="_501-not-implemented" tabindex="-1"><a class="header-anchor" href="#_501-not-implemented"><span>501 Not Implemented</span></a></h3><p>服务器不支持请求方法，因此无法处理。服务器需要支持的唯二方法（因此不能返回此代码）是 GET and HEAD.</p><h3 id="_502-bad-gateway-vs-504-gateway-timeout-网关的-两面" tabindex="-1"><a class="header-anchor" href="#_502-bad-gateway-vs-504-gateway-timeout-网关的-两面"><span>502 Bad Gateway vs 504 Gateway Timeout：网关的&quot;两面&quot;</span></a></h3><table><thead><tr><th>状态码</th><th>含义</th><th>排查重点</th></tr></thead><tbody><tr><td>502</td><td>网关收到无效响应</td><td>上游服务器故障、网络问题</td></tr><tr><td>504</td><td>网关超时未收到响应</td><td>上游服务器过载、处理时间过长</td></tr></tbody></table><p><strong>云服务场景</strong>：在微服务架构中，这两个错误常出现在API网关层</p><h3 id="_503-service-unavailable-服务器正在休息" tabindex="-1"><a class="header-anchor" href="#_503-service-unavailable-服务器正在休息"><span>503 Service Unavailable：&quot;服务器正在休息&quot;</span></a></h3><p><strong>含义</strong>：服务器暂时无法处理请求（通常是维护或过载）<br><strong>最佳实践</strong>：</p><ul><li>返回<code>Retry-After</code>头告知恢复时间</li><li>显示友好的维护页面</li><li>结合负载均衡自动切换健康节点</li></ul><h3 id="_504-gateway-timeout" tabindex="-1"><a class="header-anchor" href="#_504-gateway-timeout"><span>504 Gateway Timeout</span></a></h3><p>当服务器充当网关且无法及时获得响应时，会给出此错误响应。</p><h3 id="_505-http-version-not-supported" tabindex="-1"><a class="header-anchor" href="#_505-http-version-not-supported"><span>505 HTTP Version Not Supported</span></a></h3><p>服务器不支持请求中使用的 HTTP 版本。</p><h3 id="_506-variant-also-negotiates" tabindex="-1"><a class="header-anchor" href="#_506-variant-also-negotiates"><span>506 Variant Also Negotiates</span></a></h3><p>服务器存在内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当终点。</p><h3 id="_507-insufficient-storage-webdav" tabindex="-1"><a class="header-anchor" href="#_507-insufficient-storage-webdav"><span>507 Insufficient Storage (WebDAV)</span></a></h3><p>无法在资源上执行该方法，因为服务器无法存储成功完成请求所需的表示。</p><h3 id="_508-loop-detected-webdav" tabindex="-1"><a class="header-anchor" href="#_508-loop-detected-webdav"><span>508 Loop Detected (WebDAV)</span></a></h3><p>服务器在处理请求时检测到无限循环。</p><h3 id="_510-not-extended" tabindex="-1"><a class="header-anchor" href="#_510-not-extended"><span>510 Not Extended</span></a></h3><p>服务器需要对请求进行进一步扩展才能完成请求。</p><h3 id="_511-network-authentication-required" tabindex="-1"><a class="header-anchor" href="#_511-network-authentication-required"><span>511 Network Authentication Required</span></a></h3><p>指示客户端需要进行身份验证才能获得网络访问权限。</p><h2 id="六、趣味状态码-程序员的-彩蛋" tabindex="-1"><a class="header-anchor" href="#六、趣味状态码-程序员的-彩蛋"><span>六、趣味状态码：程序员的&quot;彩蛋&quot;</span></a></h2><p>HTTP规范中藏着一些有趣的状态码，展示了程序员的幽默感：</p><h3 id="_418-i-m-a-teapot-我是茶壶-不煮咖啡" tabindex="-1"><a class="header-anchor" href="#_418-i-m-a-teapot-我是茶壶-不煮咖啡"><span>418 I&#39;m a teapot：&quot;我是茶壶，不煮咖啡&quot;</span></a></h3><p>这是1998年愚人节RFC 2324定义的&quot;超文本咖啡壶控制协议&quot;中的状态码，表示&quot;服务器是茶壶，无法煮咖啡&quot;。虽然是玩笑，但一些框架如Spring Boot仍支持这个状态码。</p><h3 id="_451-unavailable-for-legal-reasons-法律不允许" tabindex="-1"><a class="header-anchor" href="#_451-unavailable-for-legal-reasons-法律不允许"><span>451 Unavailable For Legal Reasons：&quot;法律不允许&quot;</span></a></h3><p>表示资源因法律原因无法访问，如政府审查。名称源自小说《 Fahrenheit 451》（华氏451度，纸张的燃点）。</p><h2 id="七、实战指南-状态码诊断流程图" tabindex="-1"><a class="header-anchor" href="#七、实战指南-状态码诊断流程图"><span>七、实战指南：状态码诊断流程图</span></a></h2><p>遇到错误状态码时，可按以下流程排查：</p><ol><li><strong>4xx错误</strong>：先检查URL、请求参数、认证信息</li><li><strong>5xx错误</strong>：查看服务器日志，检查依赖服务</li><li><strong>重定向循环</strong>：检查301/302是否指向自身</li></ol><p><strong>API设计建议</strong>：</p><ul><li>200+自定义code：<code>{status:200, code:1001, msg:&quot;余额不足&quot;}</code></li><li>4xx错误返回具体原因：<code>{error:&quot;参数错误&quot;, details:{&quot;phone&quot;:&quot;格式不正确&quot;}}</code></li></ul><h2 id="八、开发者必备工具推荐" tabindex="-1"><a class="header-anchor" href="#八、开发者必备工具推荐"><span>八、开发者必备工具推荐</span></a></h2><p>浏览器Network面板：实时查看状态码（Chrome按F12）</p><p>Postman等工具：API调试时精确控制期望状态码</p><p>curl命令：curl -I URL 快速获取响应头</p><p>监控平台：设置状态码告警（502&gt;5次自动通知）</p><h2 id="总结-状态码是开发者的-听诊器" tabindex="-1"><a class="header-anchor" href="#总结-状态码是开发者的-听诊器"><span>总结：状态码是开发者的&quot;听诊器&quot;</span></a></h2><p>HTTP状态码不仅是服务器的&quot;回话&quot;，更是开发者诊断问题的&quot;听诊器&quot;。从100到599，这些三位数字背后是整个互联网的通信规则。掌握它们，你就能听懂服务器的&quot;心声&quot;，成为更高效的问题解决者。</p><p><strong>收藏指南</strong>：将本文保存到你的开发手册，遇到状态码问题时对照查阅，5分钟定位问题根源！</p><p>写文不易，如果你都看到了这里，请点个赞和在看，分享给更多的朋友；也别忘了关注星哥玩云！这里有满满的干货分享，还有轻松有趣的技术交流～点个赞、分享给身边的小伙伴，一起成长，一起玩转技术世界吧！ 😊</p>',182)]))}const i=e(o,[["render",s]]),l=JSON.parse('{"path":"/linux-basis2025/2.http-status.html","title":"从100到511的这些数字，HTTP状态码背后的秘密你知道多少？","lang":"en-US","frontmatter":{},"git":{"createdTime":1752136049000,"updatedTime":1752136049000,"contributors":[{"name":"star","username":"star","email":"star@xgss.net","commits":1,"url":"https://github.com/star"}]},"readingTime":{"minutes":14.04,"words":4211},"filePathRelative":"linux-basis2025/2.http-status.md"}');export{i as comp,l as data};
